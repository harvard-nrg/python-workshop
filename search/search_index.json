{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python for Neuroimaging! A brief history Python is a high-level, interpreted language created by Guido van Rossum . 2 to 3 Python has undergone three major revisions since it's initial release back in 1991. The most recent revision was Python 2 to 3. Python 2 still exists, but was officially deprecated on January 1st, 2020. The interpreter Instead of having to compile source code into machine code , Python executes your code one line at a time using an interpreter . starting the interpreter Python should be installed by default on most Linux and macOS systems. To start the interpreter, simply open a terminal and type python or python3 at the command prompt and hit Enter % python Python 3.8.2 (default, Mar 26 2020, 15:43:04) [Clang 11.0.3 (clang-1103.0.32.29)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Command not found If you receive a command not found error, either your system does not have Python installed, or your environment is misconfigured. Try logging into a FASSE host and use one of the existing Python modules module load ncf module load miniconda3/py39_4.11.0-ncf If that doesn't work, contact a system administrator . executing statements You can execute statements interactively by typing a statement at the prompt >>> and pressing Enter >>> 1 + 1 2 >>> Python will read the input statement, evaluate it, print the result, and loop back to the command prompt. This is known as a read-evaluate-print-loop or REPL. comments Comments begin with a hash # and will be ignored >>> # this is a comment For multi-line comments, you can use multiple hash # characters or triple quotation marks (single or double quotes work) \"\"\" I am a multiline comment \"\"\" quitting To quit the Python interpreter, type Control + D or execute the quit() or exit() functions >>> quit ()","title":"Introduction"},{"location":"#welcome-to-python-for-neuroimaging","text":"","title":"Welcome to Python for Neuroimaging!"},{"location":"#a-brief-history","text":"Python is a high-level, interpreted language created by Guido van Rossum .","title":"A brief history"},{"location":"#2-to-3","text":"Python has undergone three major revisions since it's initial release back in 1991. The most recent revision was Python 2 to 3. Python 2 still exists, but was officially deprecated on January 1st, 2020.","title":"2 to 3"},{"location":"#the-interpreter","text":"Instead of having to compile source code into machine code , Python executes your code one line at a time using an interpreter .","title":"The interpreter"},{"location":"#starting-the-interpreter","text":"Python should be installed by default on most Linux and macOS systems. To start the interpreter, simply open a terminal and type python or python3 at the command prompt and hit Enter % python Python 3.8.2 (default, Mar 26 2020, 15:43:04) [Clang 11.0.3 (clang-1103.0.32.29)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Command not found If you receive a command not found error, either your system does not have Python installed, or your environment is misconfigured. Try logging into a FASSE host and use one of the existing Python modules module load ncf module load miniconda3/py39_4.11.0-ncf If that doesn't work, contact a system administrator .","title":"starting the interpreter"},{"location":"#executing-statements","text":"You can execute statements interactively by typing a statement at the prompt >>> and pressing Enter >>> 1 + 1 2 >>> Python will read the input statement, evaluate it, print the result, and loop back to the command prompt. This is known as a read-evaluate-print-loop or REPL.","title":"executing statements"},{"location":"#comments","text":"Comments begin with a hash # and will be ignored >>> # this is a comment For multi-line comments, you can use multiple hash # characters or triple quotation marks (single or double quotes work) \"\"\" I am a multiline comment \"\"\"","title":"comments"},{"location":"#quitting","text":"To quit the Python interpreter, type Control + D or execute the quit() or exit() functions >>> quit ()","title":"quitting"},{"location":"basics/","text":"Variables, assignment, and types This may seem a bit elementary, but let's review how to define variables and go over the various primitive types in Python. Defining a variable Enter the following statement at the Python command prompt >>> to define the variable pi pi = 3.1415 Note that you do not need to use let , var , or provide any type hinting keywords before a variable declaration. You also don't need a semicolon at the end of each statement. defining a variable from an expression The right side of a variable assignment does not need to be a static value. It can be an expression a = 1 + 1 Python will evaluate the right side of the assignment operator and send the result to the left. This left-right associative property allows you to use an existing variable to redefine itself a = a + 1 Primitive types Python includes several low-level primitive data types such as integers int , decimals float , strings str , booleans bool , and null None a = 1 # int b = 3.14 # float c = \"I'm a double quoted string\" # str d = 'I \\' m a single quoted string' # str e = True # bool f = False # bool g = None # None Should I define strings use single or double quotes Using single or double quotes is mostly a stylistic choice. However, if you intend to use a single quote within a single-quoted string, or a double quote within a double-quoted string, you'll need to escape the embedded quote with a backslash \\ character as shown above. Checking types You can check the type of a variable or its class at any time by passing it to the built-in type() function. type ( a )","title":"Variables and primitive types"},{"location":"basics/#variables-assignment-and-types","text":"This may seem a bit elementary, but let's review how to define variables and go over the various primitive types in Python.","title":"Variables, assignment, and types"},{"location":"basics/#defining-a-variable","text":"Enter the following statement at the Python command prompt >>> to define the variable pi pi = 3.1415 Note that you do not need to use let , var , or provide any type hinting keywords before a variable declaration. You also don't need a semicolon at the end of each statement.","title":"Defining a variable"},{"location":"basics/#defining-a-variable-from-an-expression","text":"The right side of a variable assignment does not need to be a static value. It can be an expression a = 1 + 1 Python will evaluate the right side of the assignment operator and send the result to the left. This left-right associative property allows you to use an existing variable to redefine itself a = a + 1","title":"defining a variable from an expression"},{"location":"basics/#primitive-types","text":"Python includes several low-level primitive data types such as integers int , decimals float , strings str , booleans bool , and null None a = 1 # int b = 3.14 # float c = \"I'm a double quoted string\" # str d = 'I \\' m a single quoted string' # str e = True # bool f = False # bool g = None # None Should I define strings use single or double quotes Using single or double quotes is mostly a stylistic choice. However, if you intend to use a single quote within a single-quoted string, or a double quote within a double-quoted string, you'll need to escape the embedded quote with a backslash \\ character as shown above.","title":"Primitive types"},{"location":"basics/#checking-types","text":"You can check the type of a variable or its class at any time by passing it to the built-in type() function. type ( a )","title":"Checking types"},{"location":"cli/","text":"Writing command line tools To write a command line tool in Python, open a new plain text file named hello.py and enter the following contents #!/usr/bin/env python print ( 'Hello, World!' ) Save the file and make it executable by executing the following shell command % chmod u+x hello.py Now you can execute your script from the command line % ./hello.py Hello, World! Command line arguments Imagine that you want to write a script to download data from your local XNAT installation. You'll need to accept the command line arguments --hostname , --session , and --output-dir % ./download.py --hostname xnat.example.com \\ --session LABEL \\ --output-dir ./output Python includes a traditional C-style parser getopt , but there's a more convenient way to define and parse command line arguments using argparse . argparse defining command line arguments To define command line arguments, first import the argparse module and create an instance of argparse.ArgumentParser import argparse parser = argparse . ArgumentParser () Now, you can add your arguments to the parser object by calling parser.add_argument parser = argparse . ArgumentParser () parser . add_argument ( '--hostname' ) parser . add_argument ( '--project' ) parser . add_argument ( '--label' ) parser . add_argument ( '--output-dir' ) parsing the command line To parse the command line arguments entered by the user, simply call parser.parse_args args = parser . parse_args () accessing the command line arguments Each command line argument is automatically converted into a property on the object returned by parse_args() . The name of the property is similar but not identical to the name of the argument that was declared. There are two translation rules to remember Remove any leading dashes e.g., - or -- , from the argument name Replace any embedded dash - within the argument name with an underscore _ print ( f 'host is { args . hostname } ' ) print ( f 'project { args . project } ' ) print ( f 'label is { args . label } ' ) print ( f 'out_dir is { args . output_dir } ' )","title":"Writing command line tools"},{"location":"cli/#writing-command-line-tools","text":"To write a command line tool in Python, open a new plain text file named hello.py and enter the following contents #!/usr/bin/env python print ( 'Hello, World!' ) Save the file and make it executable by executing the following shell command % chmod u+x hello.py Now you can execute your script from the command line % ./hello.py Hello, World!","title":"Writing command line tools"},{"location":"cli/#command-line-arguments","text":"Imagine that you want to write a script to download data from your local XNAT installation. You'll need to accept the command line arguments --hostname , --session , and --output-dir % ./download.py --hostname xnat.example.com \\ --session LABEL \\ --output-dir ./output Python includes a traditional C-style parser getopt , but there's a more convenient way to define and parse command line arguments using argparse .","title":"Command line arguments"},{"location":"cli/#argparse","text":"","title":"argparse"},{"location":"cli/#defining-command-line-arguments","text":"To define command line arguments, first import the argparse module and create an instance of argparse.ArgumentParser import argparse parser = argparse . ArgumentParser () Now, you can add your arguments to the parser object by calling parser.add_argument parser = argparse . ArgumentParser () parser . add_argument ( '--hostname' ) parser . add_argument ( '--project' ) parser . add_argument ( '--label' ) parser . add_argument ( '--output-dir' )","title":"defining command line arguments"},{"location":"cli/#parsing-the-command-line","text":"To parse the command line arguments entered by the user, simply call parser.parse_args args = parser . parse_args ()","title":"parsing the command line"},{"location":"cli/#accessing-the-command-line-arguments","text":"Each command line argument is automatically converted into a property on the object returned by parse_args() . The name of the property is similar but not identical to the name of the argument that was declared. There are two translation rules to remember Remove any leading dashes e.g., - or -- , from the argument name Replace any embedded dash - within the argument name with an underscore _ print ( f 'host is { args . hostname } ' ) print ( f 'project { args . project } ' ) print ( f 'label is { args . label } ' ) print ( f 'out_dir is { args . output_dir } ' )","title":"accessing the command line arguments"},{"location":"conditional/","text":"Control flow Comparison operators Python provides all of the conventional relational operators to compare two values operator description < less than > greater than == is equal to != is not equal to <= less than or equal to >= greater than or equal to Examples include 1 < 2 2 > 1 1 == 1 1 != 2 2 <= 3 3 >= 2 These will return a bool result. Boolean operators Also referred to as logical operators , boolean operators are used to create conjunctions operator desription logic symbol and logical and p \u2227 q or logical or p \u2228 q not logical not \u00acp Some examples include 2 > 1 and 2 < 3 True or False True and not False These will return a bool result. Truthiness of values Python will interpret empty values as False and non-empty values as True . For example, it's common to execute a block of code if a list is empty. One way to do this would be a = [] if len ( a ) == 0 : print ( 'the list is empty' ) However, since Python will interpret an empty list as False you can do the following instead if not a : print ( 'the list is empty' ) Other values that evaluate to False include an empty string '' , an empty dictionary {} , the integer value 0 , the float value 0.0 , an empty tuple () , an empty set set() , and None . Exercises Exercise 1 Play around with conditional operators. Specifically, you should try comparing two strings with the less-than or greater-than operators.","title":"operators"},{"location":"conditional/#control-flow","text":"","title":"Control flow"},{"location":"conditional/#comparison-operators","text":"Python provides all of the conventional relational operators to compare two values operator description < less than > greater than == is equal to != is not equal to <= less than or equal to >= greater than or equal to Examples include 1 < 2 2 > 1 1 == 1 1 != 2 2 <= 3 3 >= 2 These will return a bool result.","title":"Comparison operators"},{"location":"conditional/#boolean-operators","text":"Also referred to as logical operators , boolean operators are used to create conjunctions operator desription logic symbol and logical and p \u2227 q or logical or p \u2228 q not logical not \u00acp Some examples include 2 > 1 and 2 < 3 True or False True and not False These will return a bool result.","title":"Boolean operators"},{"location":"conditional/#truthiness-of-values","text":"Python will interpret empty values as False and non-empty values as True . For example, it's common to execute a block of code if a list is empty. One way to do this would be a = [] if len ( a ) == 0 : print ( 'the list is empty' ) However, since Python will interpret an empty list as False you can do the following instead if not a : print ( 'the list is empty' ) Other values that evaluate to False include an empty string '' , an empty dictionary {} , the integer value 0 , the float value 0.0 , an empty tuple () , an empty set set() , and None .","title":"Truthiness of values"},{"location":"conditional/#exercises","text":"Exercise 1 Play around with conditional operators. Specifically, you should try comparing two strings with the less-than or greater-than operators.","title":"Exercises"},{"location":"dict/","text":"Data Structures Dictionaries Dictionaries are data structures that allow you to define custom indexes or keys . In other languages, dictionaries are referred to as hash maps , hash tables , or associative arrays . Dictionaries begin and end with curly braces {} and each key/value pair is separated by a comma , . You define keys and their corresponding values separated by a colon : a = { 'name' : 'Guido van Rossum' , 'yob' : 1956 } Indexing You can index into a dictionary using the defined keys, which is often easier and more robust than having to remember numeric indexes a [ 'name' ] a [ 'yob' ] Insert Use the assignment operator = to insert new items into an existing dictionary a [ 'job title' ] = 'BDFL' Update Use the assignment operator = to update dictionary items a [ 'job title' ] = None Delete Use the del keyword to delete items from a dictionary del a [ 'job title' ]","title":"Dict"},{"location":"dict/#data-structures","text":"","title":"Data Structures"},{"location":"dict/#dictionaries","text":"Dictionaries are data structures that allow you to define custom indexes or keys . In other languages, dictionaries are referred to as hash maps , hash tables , or associative arrays . Dictionaries begin and end with curly braces {} and each key/value pair is separated by a comma , . You define keys and their corresponding values separated by a colon : a = { 'name' : 'Guido van Rossum' , 'yob' : 1956 }","title":"Dictionaries"},{"location":"dict/#indexing","text":"You can index into a dictionary using the defined keys, which is often easier and more robust than having to remember numeric indexes a [ 'name' ] a [ 'yob' ]","title":"Indexing"},{"location":"dict/#insert","text":"Use the assignment operator = to insert new items into an existing dictionary a [ 'job title' ] = 'BDFL'","title":"Insert"},{"location":"dict/#update","text":"Use the assignment operator = to update dictionary items a [ 'job title' ] = None","title":"Update"},{"location":"dict/#delete","text":"Use the del keyword to delete items from a dictionary del a [ 'job title' ]","title":"Delete"},{"location":"files/","text":"Reading and writing files Reading a file To read a file, open the file using the built-in open() function and call the .read() method on the resulting file object fo = open ( 'file.txt' ) content = fo . read () To close the file, call the .close() method fo . close () character encoding Calling open() on a file without any additional arguments will assume the file being opened is a text file containing a UTF-8 encoded string. If you know that is not the case, you need to open the file in read binary mode by passing rb as the second argument fo = open ( 'file.txt' , 'rb' ) Calling the .read() method on the resulting file object will now yield a byte-string. To decode this byte-string, you must call .decode() with the correct character encoding as the first argument content = content . decode ( 'UTF-8' ) UTF-8 is quite common and backwards compatible with ASCII, but is certainly not the only character encoding. Writing a file The process for writing a file is similar to reading. Simply open the file using the built-in open() function, however you need to open the file in write mode by passing w as the second argument fo = open ( 'file.txt' , 'w' ) fo . write ( 'Hello, World! \\n ' ) It's more important to call .close() after writing a file to ensure that the write buffer has been flushed to disk fo . close () Appending to a file Appending content to an existing file requires opening the file in append mode by passing a as the second argument fo = open ( 'file.txt' , 'a' ) fo . write ( another line ') fo . close () File context manager Forgetting to call .close() is a common mistake. Fortunately, the file object returned by open() supports the context manager interface. To use a context manager, you wrap the function call in a with statement with open ( 'file.txt' , 'w' ) as fo : fo . write ( 'Hello, World! \\n ' ) The benefit is that as soon as you dedent the with block, the file will be closed. CSV files We'll take a moment to explore the csv module for reading a CSV file. To begin using the csv module, import it import csv Reading CSV (basic) Suppose this is the CSV file we're trying to read Subject,Metric 1,Metric 2 Subject_001,1,1 Subject_002,2,0 Subject_003,3,1 We would open this CSV file using open() function, then pass the resulting file object to csv.reader() . This will return a CSV reader object fo = open ( 'file.csv' ) reader = csv . reader ( fo ) Since an open CSV reader object is iterable, you can loop over it row-by-row using a for loop for row in reader : print ( row ) This loop will print the following text to the console. As shown here, each row is parsed and returned as a list [ 'Subject' , 'Metric 1' , 'Metric 2' ] [ 'Subject_001' , '1' , '1' ] [ 'Subject_002' , '2' , '0' ] [ 'Subject_003' , '3' , '1' ] Dictionary reader The first row of a CSV file usually contains column headers. It's useful to to combine each row with the column headers so that you can retrive items using dictionary-based indexing. The csv.DictReader can do this for you fo = open ( 'file.csv' ) reader = csv . DictReader ( fo ) for row in reader : print ( row [ 'Metric 1' ]) Pandas You should also check out pandas which has even more advanced CSV parsing and querying capabilities.","title":"Reading and writing files"},{"location":"files/#reading-and-writing-files","text":"","title":"Reading and writing files"},{"location":"files/#reading-a-file","text":"To read a file, open the file using the built-in open() function and call the .read() method on the resulting file object fo = open ( 'file.txt' ) content = fo . read () To close the file, call the .close() method fo . close ()","title":"Reading a file"},{"location":"files/#character-encoding","text":"Calling open() on a file without any additional arguments will assume the file being opened is a text file containing a UTF-8 encoded string. If you know that is not the case, you need to open the file in read binary mode by passing rb as the second argument fo = open ( 'file.txt' , 'rb' ) Calling the .read() method on the resulting file object will now yield a byte-string. To decode this byte-string, you must call .decode() with the correct character encoding as the first argument content = content . decode ( 'UTF-8' ) UTF-8 is quite common and backwards compatible with ASCII, but is certainly not the only character encoding.","title":"character encoding"},{"location":"files/#writing-a-file","text":"The process for writing a file is similar to reading. Simply open the file using the built-in open() function, however you need to open the file in write mode by passing w as the second argument fo = open ( 'file.txt' , 'w' ) fo . write ( 'Hello, World! \\n ' ) It's more important to call .close() after writing a file to ensure that the write buffer has been flushed to disk fo . close ()","title":"Writing a file"},{"location":"files/#appending-to-a-file","text":"Appending content to an existing file requires opening the file in append mode by passing a as the second argument fo = open ( 'file.txt' , 'a' ) fo . write ( another line ') fo . close ()","title":"Appending to a file"},{"location":"files/#file-context-manager","text":"Forgetting to call .close() is a common mistake. Fortunately, the file object returned by open() supports the context manager interface. To use a context manager, you wrap the function call in a with statement with open ( 'file.txt' , 'w' ) as fo : fo . write ( 'Hello, World! \\n ' ) The benefit is that as soon as you dedent the with block, the file will be closed.","title":"File context manager"},{"location":"files/#csv-files","text":"We'll take a moment to explore the csv module for reading a CSV file. To begin using the csv module, import it import csv","title":"CSV files"},{"location":"files/#reading-csv-basic","text":"Suppose this is the CSV file we're trying to read Subject,Metric 1,Metric 2 Subject_001,1,1 Subject_002,2,0 Subject_003,3,1 We would open this CSV file using open() function, then pass the resulting file object to csv.reader() . This will return a CSV reader object fo = open ( 'file.csv' ) reader = csv . reader ( fo ) Since an open CSV reader object is iterable, you can loop over it row-by-row using a for loop for row in reader : print ( row ) This loop will print the following text to the console. As shown here, each row is parsed and returned as a list [ 'Subject' , 'Metric 1' , 'Metric 2' ] [ 'Subject_001' , '1' , '1' ] [ 'Subject_002' , '2' , '0' ] [ 'Subject_003' , '3' , '1' ]","title":"Reading CSV (basic)"},{"location":"files/#dictionary-reader","text":"The first row of a CSV file usually contains column headers. It's useful to to combine each row with the column headers so that you can retrive items using dictionary-based indexing. The csv.DictReader can do this for you fo = open ( 'file.csv' ) reader = csv . DictReader ( fo ) for row in reader : print ( row [ 'Metric 1' ]) Pandas You should also check out pandas which has even more advanced CSV parsing and querying capabilities.","title":"Dictionary reader"},{"location":"for/","text":"Control flow The for loop A for loop allows the same block of code to be executed multiple times for item in iterable : code to be executed Iteration Many of the data structures we've reviewed are defined as iterables in Python. Suppose we have a list of scan information where each item in the list contains a dict of scan properties scans = [ { 'num' : 1 , 'type' : 'LOCALIZER' , }, { 'num' : 2 , 'type' : 'MEMPRAGE' }, { 'num' : 3 , 'type' : 'BOLD' }, { 'num' : 4 , 'type' : 'BOLD' } ] If you want to retrieve the scan numbers for all BOLD scans, you could use a for loop to iterate over scans and call the same block of code to populate a list of scan numbers numbers = [] for scan in scans : if scan [ 'type' ] == 'BOLD' : numbers . append ( scan [ 'num' ]) print ( numbers ) This will print the result [3, 4] . Iterating over a dictionary It's common to iterate over a dict , however there are some subtle differences. By default, when you iterate over a dict you'll only receive its keys a = { 'key1' : 1 , 'key2' : 2 , 'key3' : 3 } for key in a : value = a [ key ] print ( value ) If you want to iterate over the dict returning both the key and value pairs, you would use the following syntax for key , value in a . items (): print ( 'key =' , key , 'value =' , value ) The .items() method on a dictionary will return all key/value pairs as a list of tuples. The for loop shown above is unpacking each tuple into the separate variables for key and value .","title":"for"},{"location":"for/#control-flow","text":"","title":"Control flow"},{"location":"for/#the-for-loop","text":"A for loop allows the same block of code to be executed multiple times for item in iterable : code to be executed","title":"The for loop"},{"location":"for/#iteration","text":"Many of the data structures we've reviewed are defined as iterables in Python. Suppose we have a list of scan information where each item in the list contains a dict of scan properties scans = [ { 'num' : 1 , 'type' : 'LOCALIZER' , }, { 'num' : 2 , 'type' : 'MEMPRAGE' }, { 'num' : 3 , 'type' : 'BOLD' }, { 'num' : 4 , 'type' : 'BOLD' } ] If you want to retrieve the scan numbers for all BOLD scans, you could use a for loop to iterate over scans and call the same block of code to populate a list of scan numbers numbers = [] for scan in scans : if scan [ 'type' ] == 'BOLD' : numbers . append ( scan [ 'num' ]) print ( numbers ) This will print the result [3, 4] .","title":"Iteration"},{"location":"for/#iterating-over-a-dictionary","text":"It's common to iterate over a dict , however there are some subtle differences. By default, when you iterate over a dict you'll only receive its keys a = { 'key1' : 1 , 'key2' : 2 , 'key3' : 3 } for key in a : value = a [ key ] print ( value ) If you want to iterate over the dict returning both the key and value pairs, you would use the following syntax for key , value in a . items (): print ( 'key =' , key , 'value =' , value ) The .items() method on a dictionary will return all key/value pairs as a list of tuples. The for loop shown above is unpacking each tuple into the separate variables for key and value .","title":"Iterating over a dictionary"},{"location":"formats/","text":"DICOM and NIFTI In this section, we're going to look at two Python libraries for interacting with common neuroimaging file formats pydicom and nibabel . Use a virtual environment To have full control over installing the packages described in this section, use a virtual environment . DICOM DICOM is perhaps the most popular imaging file format used within the medical imaging community. One of the more popular Python packages for reading and writing DICOM files is pydicom . You'll need to install numpy for more advanced functionality. pip install pydicom numpy reading a file To read a DICOM file into variable named ds , use dcmread() import pydicom ds = pydicom . dcmread ( 'file.dcm' ) Lazy loading The pydicom.dcmread() function will only read the DICOM file headers until you attempt to access the pixel data. This design choice saves time and computational resources. reading headers DICOM headers are identified by their group and element . Some example headers include Name group element Study Date 0008 0020 Study Time 0008 0030 Patient Name 0010 0010 Series Number 0020 0011 Accession Number 0008 0050 Instance ID 0020 0013 Study UID 0020 000D Series UID 0020 000E You can access these headers by indexing into the ds object using a tuple of ( group, element ) . To access the Patient Name for example, you would use element = ds [( '0010' , '0010' )] In the example above, the returned element will be an instance of pydicom.dataelem.DataElement . Use the value property to access the value of this element patientname = element . value reading pixel data To read the DICOM pixel data as a series of bytes, you can access the PixelData property pixels = ds . PixelData To receive the pixel data as a more useful numpy array, use the pixel_array property pixels = ds . pixel_array visualizing pixel data Let's take a look at matplotlib to visualize DICOM pixel data. First, you need to install matplotlib pip install matplotlib Now, import matplotlib.pyplot and use imshow() to render the pixel data (a NumPy ndarray ) as an image import matplotlib.pyplot as plt plt . imshow ( ds . pixel_array ) plt . show () NIfTI For reading and writing NIFTI files, use the nibabel package pip install nibabel reading a file To read a NIFTI file, use nibabel.load() import nibabel ds = nibabel . load ( 'file.nii.gz' ) reading headers The NIFTI file headers are stored in a header property on the ds object. Since the header property behaves like a dictionary, you can use a for loop to iterate over all the headers formatter = f 'header = { header } value = { value } ' for header , value in ds . header . items (): print ( formatter ) reading pixel data The .get_fdata() method will return the NIfTI pixel data as a NumPy array pixels = ds . get_fdata () Memory efficiency The ds.get_fdata() method has many excellent features for handling large images efficiently. For more details, read the official documentation here . visualizing pixel data Let's take a look at matplotlib to visualize NIfTI pixel data. First, you need to install matplotlib pip install matplotlib Now, import matplotlib.pyplot and use imshow() to render image 50 along the z-axis import matplotlib.pyplot as plt fdata = ds . get_fdata () plt . imshow ( fdata [:,:, 50 ]) plt . show ()","title":"DICOM and NIFTI"},{"location":"formats/#dicom-and-nifti","text":"In this section, we're going to look at two Python libraries for interacting with common neuroimaging file formats pydicom and nibabel . Use a virtual environment To have full control over installing the packages described in this section, use a virtual environment .","title":"DICOM and NIFTI"},{"location":"formats/#dicom","text":"DICOM is perhaps the most popular imaging file format used within the medical imaging community. One of the more popular Python packages for reading and writing DICOM files is pydicom . You'll need to install numpy for more advanced functionality. pip install pydicom numpy","title":"DICOM"},{"location":"formats/#reading-a-file","text":"To read a DICOM file into variable named ds , use dcmread() import pydicom ds = pydicom . dcmread ( 'file.dcm' ) Lazy loading The pydicom.dcmread() function will only read the DICOM file headers until you attempt to access the pixel data. This design choice saves time and computational resources.","title":"reading a file"},{"location":"formats/#reading-headers","text":"DICOM headers are identified by their group and element . Some example headers include Name group element Study Date 0008 0020 Study Time 0008 0030 Patient Name 0010 0010 Series Number 0020 0011 Accession Number 0008 0050 Instance ID 0020 0013 Study UID 0020 000D Series UID 0020 000E You can access these headers by indexing into the ds object using a tuple of ( group, element ) . To access the Patient Name for example, you would use element = ds [( '0010' , '0010' )] In the example above, the returned element will be an instance of pydicom.dataelem.DataElement . Use the value property to access the value of this element patientname = element . value","title":"reading headers"},{"location":"formats/#reading-pixel-data","text":"To read the DICOM pixel data as a series of bytes, you can access the PixelData property pixels = ds . PixelData To receive the pixel data as a more useful numpy array, use the pixel_array property pixels = ds . pixel_array","title":"reading pixel data"},{"location":"formats/#visualizing-pixel-data","text":"Let's take a look at matplotlib to visualize DICOM pixel data. First, you need to install matplotlib pip install matplotlib Now, import matplotlib.pyplot and use imshow() to render the pixel data (a NumPy ndarray ) as an image import matplotlib.pyplot as plt plt . imshow ( ds . pixel_array ) plt . show ()","title":"visualizing pixel data"},{"location":"formats/#nifti","text":"For reading and writing NIFTI files, use the nibabel package pip install nibabel","title":"NIfTI"},{"location":"formats/#reading-a-file_1","text":"To read a NIFTI file, use nibabel.load() import nibabel ds = nibabel . load ( 'file.nii.gz' )","title":"reading a file"},{"location":"formats/#reading-headers_1","text":"The NIFTI file headers are stored in a header property on the ds object. Since the header property behaves like a dictionary, you can use a for loop to iterate over all the headers formatter = f 'header = { header } value = { value } ' for header , value in ds . header . items (): print ( formatter )","title":"reading headers"},{"location":"formats/#reading-pixel-data_1","text":"The .get_fdata() method will return the NIfTI pixel data as a NumPy array pixels = ds . get_fdata () Memory efficiency The ds.get_fdata() method has many excellent features for handling large images efficiently. For more details, read the official documentation here .","title":"reading pixel data"},{"location":"formats/#visualizing-pixel-data_1","text":"Let's take a look at matplotlib to visualize NIfTI pixel data. First, you need to install matplotlib pip install matplotlib Now, import matplotlib.pyplot and use imshow() to render image 50 along the z-axis import matplotlib.pyplot as plt fdata = ds . get_fdata () plt . imshow ( fdata [:,:, 50 ]) plt . show ()","title":"visualizing pixel data"},{"location":"functions/","text":"Functions Batteries included The Python documentation includes an excellent tour of the standard library . This tutorial has made use of several built-in Python functions already, including type() , set() , len() , and range() . positional arguments The simplest form of a function call takes one or more positional arguments . For example, the sorted() function can be called with only a single positional argument a = [ 3 , 1 , 5 , 4 , 2 ] sorted ( a ) This function will return a sorted version of the input list [ 1, 2, 3, 4, 5 ] . keyword arguments If you read through the documentation for the sorted() function, you'll see that it can accept two more keyword arguments def sorted ( iterable , key = None , reverse = False ) These arguments are optional since they've been defined with the default values None and False . You can however override either of these arguments by referencing it by keyword . For example, you can pass reverse=True to reverse the sort order sorted ( a , reverse = True ) Defining a function Functions are defined using the def keyword, followed by the name of the function, followed by a comma separated list of arguments within parentheses () def my_function ( a , b , c ) This is known as a function signature . Implementing a function The function's implementation should exist within an indented block directly below the function signature. You must append a colon : to the end of the function signature def function ( a , b , c ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Now you can invoke this function like any other function from the standard libary function ( 1 , 2 , 3 ) This will print the following text to the console a is 1 b is 2 c is 3 defining keyword arguments Positional arguments are always declared first in a function signature. These arguments will be required to invoke the function. If you'd like to define any optional arguments, those must be declared after the positional arguments using the keyword=default syntax def function ( a , b = 8 , c = 16 ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Given the function definition above, a is required, b is optional (with a default value 8 ), and c is optional (with a default value 16 ). When calling this function, if you wish to override any of these optional keyword arguments, you can refer to them by keyword function ( 1 , c = 3 ) This would print the following text to the console a is 1 b is 8 c is 3 Returning values Often times you will want your function to manipulate some input data and return a computed result. This is accomplished using a return statement def function ( a , b , c ): return ( a + b ) / c If your function has a return value, you can store that value within a variable using the assignment operator = result = function ( 1 , 2 , 3 )","title":"Functions"},{"location":"functions/#functions","text":"Batteries included The Python documentation includes an excellent tour of the standard library . This tutorial has made use of several built-in Python functions already, including type() , set() , len() , and range() .","title":"Functions"},{"location":"functions/#positional-arguments","text":"The simplest form of a function call takes one or more positional arguments . For example, the sorted() function can be called with only a single positional argument a = [ 3 , 1 , 5 , 4 , 2 ] sorted ( a ) This function will return a sorted version of the input list [ 1, 2, 3, 4, 5 ] .","title":"positional arguments"},{"location":"functions/#keyword-arguments","text":"If you read through the documentation for the sorted() function, you'll see that it can accept two more keyword arguments def sorted ( iterable , key = None , reverse = False ) These arguments are optional since they've been defined with the default values None and False . You can however override either of these arguments by referencing it by keyword . For example, you can pass reverse=True to reverse the sort order sorted ( a , reverse = True )","title":"keyword arguments"},{"location":"functions/#defining-a-function","text":"Functions are defined using the def keyword, followed by the name of the function, followed by a comma separated list of arguments within parentheses () def my_function ( a , b , c ) This is known as a function signature .","title":"Defining a function"},{"location":"functions/#implementing-a-function","text":"The function's implementation should exist within an indented block directly below the function signature. You must append a colon : to the end of the function signature def function ( a , b , c ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Now you can invoke this function like any other function from the standard libary function ( 1 , 2 , 3 ) This will print the following text to the console a is 1 b is 2 c is 3","title":"Implementing a function"},{"location":"functions/#defining-keyword-arguments","text":"Positional arguments are always declared first in a function signature. These arguments will be required to invoke the function. If you'd like to define any optional arguments, those must be declared after the positional arguments using the keyword=default syntax def function ( a , b = 8 , c = 16 ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Given the function definition above, a is required, b is optional (with a default value 8 ), and c is optional (with a default value 16 ). When calling this function, if you wish to override any of these optional keyword arguments, you can refer to them by keyword function ( 1 , c = 3 ) This would print the following text to the console a is 1 b is 8 c is 3","title":"defining keyword arguments"},{"location":"functions/#returning-values","text":"Often times you will want your function to manipulate some input data and return a computed result. This is accomplished using a return statement def function ( a , b , c ): return ( a + b ) / c If your function has a return value, you can store that value within a variable using the assignment operator = result = function ( 1 , 2 , 3 )","title":"Returning values"},{"location":"if/","text":"Control flow Indentation is important Python uses indentation or the off-side rule to declare a block of code. A code block is considered open on indent and closed on dedent. The if condition The general syntax of an if statement in Python is if condition : code to execute if True In the example below, since a == 10 evaluates to True the indented block of code will be executed a = 10 if a == 10 : print ( 'condition is True' ) The else clause If you want to execute a different block of code if the evaluated condition returns False , you would use an else clause if a == 0 : print ( 'condition is True' ) else : print ( 'condition is False' ) The elif clause We can further complicate this if statement with an elif , short for else if if a == 0 : print ( 'a is equal to 0' ) elif a == 10 : print ( 'a is equal to 10' ) else : print ( 'a is not equal to 0 or 10' )","title":"if"},{"location":"if/#control-flow","text":"Indentation is important Python uses indentation or the off-side rule to declare a block of code. A code block is considered open on indent and closed on dedent.","title":"Control flow"},{"location":"if/#the-if-condition","text":"The general syntax of an if statement in Python is if condition : code to execute if True In the example below, since a == 10 evaluates to True the indented block of code will be executed a = 10 if a == 10 : print ( 'condition is True' )","title":"The if condition"},{"location":"if/#the-else-clause","text":"If you want to execute a different block of code if the evaluated condition returns False , you would use an else clause if a == 0 : print ( 'condition is True' ) else : print ( 'condition is False' )","title":"The else clause"},{"location":"if/#the-elif-clause","text":"We can further complicate this if statement with an elif , short for else if if a == 0 : print ( 'a is equal to 0' ) elif a == 10 : print ( 'a is equal to 10' ) else : print ( 'a is not equal to 0 or 10' )","title":"The elif clause"},{"location":"learn/","text":"Machine learning scikit-learn is one of many excellent machine learning libraries for Python. Use a virtual environment To have full control over installing the packages described within this section, consider using virtual environment demonstrated here . Installation Use pip to install scikit-learn pip install scikit-learn The name of the module is sklearn import sklearn Iris data set One of the canonical examples within the machine learning community is classifying Iris plants from various petal and sepal features. This is such a common example in fact, the Iris data set is included within sklearn . All you have to do is import the datasets module and load it from sklearn import datasets iris = datasets . load_iris () The Iris data set contains 150 examples of Iris plant. There are 50 examples of 3 classes, or targets \u2014 setosa, versicolour, and virgincia. Each example contains 4 different measurements, or features \u2014 sepal length, sepal width, petal length, and petal width. The sklearn data set contains the features in iris.data and the corresponding classes are found within iris.target . Building a classifier In this example, we'll build a Decision Tree classifier to predict Iris plants from petal and sepal features. First, we'll load the tree module from sklearn import tree Next, we'll create a DecisionTreeClassifer with a maximum depth of 2 classifier = tree . DecisionTreeClassifier ( max_depth = 2 ) Fitting data (training) We can train our classifier on the data set using the fit method classifier = classifier . fit ( iris . data , iris . target ) Visualizing the classifer Before moving on to prediction, let's visualize our classifier using the export_text function from sklearn.tree from sklearn.tree import export_text text = export_text ( classifier , feature_names = iris [ 'feature_names' ]) print ( text ) You should see the following output |--- petal length ( cm ) <= 2.45 | |--- class : 0 |--- petal length ( cm ) > 2.45 | |--- petal width ( cm ) <= 1.75 | | |--- class : 1 | |--- petal width ( cm ) > 1.75 | | |--- class : 2 Class names for this example can be found in iris['target_names'] . Prediction Given an unseen input feature vector [ 1.0, 1.0, 2.5, 1.75 ] you can predict its class using the .predict() method on our new model classifier . predict ([[ 1.0 , 1.0 , 2.5 , 1.75 ]]) This should return class 1 . If you manually run this input vector through the Decision Tree rules yourself, you can verify that this is correct.","title":"Machine learning primer"},{"location":"learn/#machine-learning","text":"scikit-learn is one of many excellent machine learning libraries for Python. Use a virtual environment To have full control over installing the packages described within this section, consider using virtual environment demonstrated here .","title":"Machine learning"},{"location":"learn/#installation","text":"Use pip to install scikit-learn pip install scikit-learn The name of the module is sklearn import sklearn","title":"Installation"},{"location":"learn/#iris-data-set","text":"One of the canonical examples within the machine learning community is classifying Iris plants from various petal and sepal features. This is such a common example in fact, the Iris data set is included within sklearn . All you have to do is import the datasets module and load it from sklearn import datasets iris = datasets . load_iris () The Iris data set contains 150 examples of Iris plant. There are 50 examples of 3 classes, or targets \u2014 setosa, versicolour, and virgincia. Each example contains 4 different measurements, or features \u2014 sepal length, sepal width, petal length, and petal width. The sklearn data set contains the features in iris.data and the corresponding classes are found within iris.target .","title":"Iris data set"},{"location":"learn/#building-a-classifier","text":"In this example, we'll build a Decision Tree classifier to predict Iris plants from petal and sepal features. First, we'll load the tree module from sklearn import tree Next, we'll create a DecisionTreeClassifer with a maximum depth of 2 classifier = tree . DecisionTreeClassifier ( max_depth = 2 )","title":"Building a classifier"},{"location":"learn/#fitting-data-training","text":"We can train our classifier on the data set using the fit method classifier = classifier . fit ( iris . data , iris . target )","title":"Fitting data (training)"},{"location":"learn/#visualizing-the-classifer","text":"Before moving on to prediction, let's visualize our classifier using the export_text function from sklearn.tree from sklearn.tree import export_text text = export_text ( classifier , feature_names = iris [ 'feature_names' ]) print ( text ) You should see the following output |--- petal length ( cm ) <= 2.45 | |--- class : 0 |--- petal length ( cm ) > 2.45 | |--- petal width ( cm ) <= 1.75 | | |--- class : 1 | |--- petal width ( cm ) > 1.75 | | |--- class : 2 Class names for this example can be found in iris['target_names'] .","title":"Visualizing the classifer"},{"location":"learn/#prediction","text":"Given an unseen input feature vector [ 1.0, 1.0, 2.5, 1.75 ] you can predict its class using the .predict() method on our new model classifier . predict ([[ 1.0 , 1.0 , 2.5 , 1.75 ]]) This should return class 1 . If you manually run this input vector through the Decision Tree rules yourself, you can verify that this is correct.","title":"Prediction"},{"location":"list/","text":"Data structures Lists Also known as arrays in other languages, a list in Python begins and ends with square brackets [] and individual items are separated with a comma , Spaces don't matter here. a = [ 1 , 2 , 3 , 4 ] Do I need to specify the size of the list in advance No. Since Python is interpreted and garbage collected there's no need to explicitly allocate memory, free memory, or declare the size of a list in advance. You can store any type of data in a list a = [ 'Hello' , 'World!' ] You can even store multiple types of data, including other lists a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] Split up long lines In the example below, you'll see a list printed with each item on a separate line. It's considered good practice to split lines at 80 characters for readability. Indexing Retrieving items from a list is called indexing or subscripting . Let's revisit the list from earlier a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] The indexes are as follows index value type 0 1.0 float 1 'Hello, World!' str 2 [ 5.0, True, None ] list In Python, list indexes start at 0 and increment to the length of the list minus 1 . Let's retrieve a few items a [ 0 ] a [ 1 ] a [ 2 ] Insert Python has a few different ways to insert new items into an existing list. More commonly, you will use the .insert() method. This method accepts two arguments. The first argument is a list index and the second argument is the value you want to insert at that index a . insert ( 0 , 'foobar' ) This will insert the string foobar at index 0 , pushing all subsequent items forward. Update Use the assignment operator = to update an item at a specific index a [ 1 ] = 999 This will replace the value at index 1 with the integer value 999 . Delete Use the del keyword to delete an item from a list del a [ 1 ] This will delete the value at index 1 and shift all subsequent items back. Read the documentation Refer to the official documentation here for all available list operations. Length To see the length of a list, pass it to the built-in len() function len ( a ) This function will return an int . Exists To check whether or not a specific value exists within a given list, use the in keyword 20 in a This statement will return a bool . Slicing Slicing is a powerful feature built into Python. If you've ever used C or Matlab, the syntax should be familiar. Let's define a list containing the numbers 0 through 20 using the built-in range() function For range() to return all numbers from 1 to 20 , you have to specify that you want numbers from 1 to 21 . a = list ( range ( 1 , 21 )) Slice syntax is defined using start:end[:step] where step is optional. If you want to retrieve the first 10 items, you would specify the following slice a [ 0 : 10 ] If you omit the start index, it will default to 0 a [: 10 ] Add a colon : and specify a step value of 2 to get every other item a [: 20 : 2 ] If you don't know the length of the list , omit the end index to default to the maximum length a [:: 2 ] For more advanced information, visit the official documentation here","title":"List"},{"location":"list/#data-structures","text":"","title":"Data structures"},{"location":"list/#lists","text":"Also known as arrays in other languages, a list in Python begins and ends with square brackets [] and individual items are separated with a comma , Spaces don't matter here. a = [ 1 , 2 , 3 , 4 ] Do I need to specify the size of the list in advance No. Since Python is interpreted and garbage collected there's no need to explicitly allocate memory, free memory, or declare the size of a list in advance. You can store any type of data in a list a = [ 'Hello' , 'World!' ] You can even store multiple types of data, including other lists a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] Split up long lines In the example below, you'll see a list printed with each item on a separate line. It's considered good practice to split lines at 80 characters for readability.","title":"Lists"},{"location":"list/#indexing","text":"Retrieving items from a list is called indexing or subscripting . Let's revisit the list from earlier a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] The indexes are as follows index value type 0 1.0 float 1 'Hello, World!' str 2 [ 5.0, True, None ] list In Python, list indexes start at 0 and increment to the length of the list minus 1 . Let's retrieve a few items a [ 0 ] a [ 1 ] a [ 2 ]","title":"Indexing"},{"location":"list/#insert","text":"Python has a few different ways to insert new items into an existing list. More commonly, you will use the .insert() method. This method accepts two arguments. The first argument is a list index and the second argument is the value you want to insert at that index a . insert ( 0 , 'foobar' ) This will insert the string foobar at index 0 , pushing all subsequent items forward.","title":"Insert"},{"location":"list/#update","text":"Use the assignment operator = to update an item at a specific index a [ 1 ] = 999 This will replace the value at index 1 with the integer value 999 .","title":"Update"},{"location":"list/#delete","text":"Use the del keyword to delete an item from a list del a [ 1 ] This will delete the value at index 1 and shift all subsequent items back. Read the documentation Refer to the official documentation here for all available list operations.","title":"Delete"},{"location":"list/#length","text":"To see the length of a list, pass it to the built-in len() function len ( a ) This function will return an int .","title":"Length"},{"location":"list/#exists","text":"To check whether or not a specific value exists within a given list, use the in keyword 20 in a This statement will return a bool .","title":"Exists"},{"location":"list/#slicing","text":"Slicing is a powerful feature built into Python. If you've ever used C or Matlab, the syntax should be familiar. Let's define a list containing the numbers 0 through 20 using the built-in range() function For range() to return all numbers from 1 to 20 , you have to specify that you want numbers from 1 to 21 . a = list ( range ( 1 , 21 )) Slice syntax is defined using start:end[:step] where step is optional. If you want to retrieve the first 10 items, you would specify the following slice a [ 0 : 10 ] If you omit the start index, it will default to 0 a [: 10 ] Add a colon : and specify a step value of 2 to get every other item a [: 20 : 2 ] If you don't know the length of the list , omit the end index to default to the maximum length a [:: 2 ] For more advanced information, visit the official documentation here","title":"Slicing"},{"location":"math/","text":"Math operators Python has fairly conventional mathematical operators for addition + , subtraction - , multiplication * , division / , and exponents ** . To demonstrate these, let's define two variables a and b and execute some basic arithmetic operations a = 1 b = 10 a + b a - b a * b a / b b ** 2 Dividing two int types returns a float If you're familiar with languages like C or Python 2, you might be surprised to find that Python 3 returns a float even when you divide two ints . Exercises Exercise 1 Play around with types and arithmetic expressions on your own. Define variables, run arithmetic expressions, and explore what happens if you multiply e.g., a str with an int .","title":"Math operators"},{"location":"math/#math-operators","text":"Python has fairly conventional mathematical operators for addition + , subtraction - , multiplication * , division / , and exponents ** . To demonstrate these, let's define two variables a and b and execute some basic arithmetic operations a = 1 b = 10 a + b a - b a * b a / b b ** 2 Dividing two int types returns a float If you're familiar with languages like C or Python 2, you might be surprised to find that Python 3 returns a float even when you divide two ints .","title":"Math operators"},{"location":"math/#exercises","text":"Exercise 1 Play around with types and arithmetic expressions on your own. Define variables, run arithmetic expressions, and explore what happens if you multiply e.g., a str with an int .","title":"Exercises"},{"location":"modules/","text":"Importing and using modules The following section will explore how to tap into the rest of the Python standard library by way of importing modules. The os module The os module provides functions that allow you to interact with the operating system. To begin using functions from the os module, you need to import it import os Joining paths os.path.join allows you to combine strings with the appropriate path separator os . path . join ( '/path/to/data/' , 'sub-001' , 'ses-001' ) This function call will return the path /path/to/data/sub-001/ses-001 . Listing a directory os.listdir will list directory contents, similar to the ls utility from GNU coreutils for entry in os . listdir ( '.' ): print ( entry ) Walking a directory If you want to crawl over a directory and each subdirectory from the command line, you would likely run a command like ls -R or find . In Python, you could use os.walk for root , dirs , files in os . walk ( '.' ): for file in files : fullfile = os . path . join ( root , file ) print ( fullfile ) Table of shell commands Here's a quick list of commonly used Python functions and their corresponding GNU/Linux commands Linux command Python function cd os.chdir pwd os.getcwd chmod os.chmod chown os.chown rm os.remove mv os.rename The shutil module Similar to the os module, shutil contains more high-level functions for interacting with files and directories import shutil Copying a file To copy a file, you should use shutil.copy2 . This function accepts the source and destination files shutil . copy2 ( '/path/source.txt' , '/path/destination.txt' ) Python contains several functions for copying a file. There's copy , copyfile , and copy2 . copy2 may be preferred under most circumstances since it preserves file metadata. Copying a directory To copy an entire directory tree, you would typically use the cp -R commnad. In Python, you can use shutil.copytree . This function accepts the source and destination directories shutil . copytree ( '/path/source' , '/path/destination' ) Deleting a directory To delete an entire directory from the command line, you would typically use rm -r and say a quick prayer. In Python, you would use shutil.rmtree . This function accepts the directory to delete Destructive command You will not be asked for confirmation. Use at your own risk. shutil . rmtree ( '/please/be/careful' ) from x import y Instead of importing a module and calling a function import os os . listdir () you can use a from statement to import only the function you need from os import listdir listdir ()","title":"Importing modules"},{"location":"modules/#importing-and-using-modules","text":"The following section will explore how to tap into the rest of the Python standard library by way of importing modules.","title":"Importing and using modules"},{"location":"modules/#the-os-module","text":"The os module provides functions that allow you to interact with the operating system. To begin using functions from the os module, you need to import it import os","title":"The os module"},{"location":"modules/#joining-paths","text":"os.path.join allows you to combine strings with the appropriate path separator os . path . join ( '/path/to/data/' , 'sub-001' , 'ses-001' ) This function call will return the path /path/to/data/sub-001/ses-001 .","title":"Joining paths"},{"location":"modules/#listing-a-directory","text":"os.listdir will list directory contents, similar to the ls utility from GNU coreutils for entry in os . listdir ( '.' ): print ( entry )","title":"Listing a directory"},{"location":"modules/#walking-a-directory","text":"If you want to crawl over a directory and each subdirectory from the command line, you would likely run a command like ls -R or find . In Python, you could use os.walk for root , dirs , files in os . walk ( '.' ): for file in files : fullfile = os . path . join ( root , file ) print ( fullfile )","title":"Walking a directory"},{"location":"modules/#table-of-shell-commands","text":"Here's a quick list of commonly used Python functions and their corresponding GNU/Linux commands Linux command Python function cd os.chdir pwd os.getcwd chmod os.chmod chown os.chown rm os.remove mv os.rename","title":"Table of shell commands"},{"location":"modules/#the-shutil-module","text":"Similar to the os module, shutil contains more high-level functions for interacting with files and directories import shutil","title":"The shutil module"},{"location":"modules/#copying-a-file","text":"To copy a file, you should use shutil.copy2 . This function accepts the source and destination files shutil . copy2 ( '/path/source.txt' , '/path/destination.txt' ) Python contains several functions for copying a file. There's copy , copyfile , and copy2 . copy2 may be preferred under most circumstances since it preserves file metadata.","title":"Copying a file"},{"location":"modules/#copying-a-directory","text":"To copy an entire directory tree, you would typically use the cp -R commnad. In Python, you can use shutil.copytree . This function accepts the source and destination directories shutil . copytree ( '/path/source' , '/path/destination' )","title":"Copying a directory"},{"location":"modules/#deleting-a-directory","text":"To delete an entire directory from the command line, you would typically use rm -r and say a quick prayer. In Python, you would use shutil.rmtree . This function accepts the directory to delete Destructive command You will not be asked for confirmation. Use at your own risk. shutil . rmtree ( '/please/be/careful' )","title":"Deleting a directory"},{"location":"modules/#from-x-import-y","text":"Instead of importing a module and calling a function import os os . listdir () you can use a from statement to import only the function you need from os import listdir listdir ()","title":"from x import y"},{"location":"print/","text":"Print and string formatting One of the most tried and true debugging tools is print . Make liberal use of print to output text from your programs that would be useful for troubleshooting and monitoring progress. Simple use case You can pass any value to print that can be represented as a string Most types of data in Python can be represented as a string. print ( 'Hello, World!' ) print ( 1 ) print ( 3.14 ) print ( True ) print ( None ) print ([ 1 , 2 , 3 ]) String formatting Format strings allow you to create more complex strings containing plain text and existing variables. Read the documentation String formatting is a whole mini-language within the Python language itself. I suggest referring to the official documentation for more. Basic example You define a format string like a any other string, except you must prefix the string with a f . Within the format string, you can use curly braces {} to reference a variable a = 'World' print ( f 'Hello, { a } !' ) In this example, Python will substitute the placeholder {a} with the value from the variable a which will result in the string Hello, World! . Real world example Format strings are sometimes used to dynamically build shell commands. For example files = [ [ 'subject_a.dcm' , 'subject_a.nii.gz' ], [ 'subject_b.dcm' , 'subject_b.nii.gz' ], [ 'subject_c.dcm' , 'subject_c.nii.gz' ] ] for infile , outfile in files : command = f 'mri_convert { infile } { outfile } ' print ( command ) This will print the following shell commands mri_convert subject_a.dcm subject_a.nii.gz mri_convert subject_b.dcm subject_b.nii.gz mri_convert subject_c.dcm subject_c.nii.gz Rounding floats It's common for a developer to specify how a float value should be displayed within a formatted string. To do this, you can add a format specifier to your placeholder using {variable:specifier} syntax. For example, if you want your format string to round the variable pi to 4 decimal places, you would append 0.4f to pi pi = 3.1415926 print ( f '\u03c0 rounded to 4 decimal places is { pi : 0.4f } ' ) For more information on format specifiers, refer to the official documentation here .","title":"Print and string formatting"},{"location":"print/#print-and-string-formatting","text":"One of the most tried and true debugging tools is print . Make liberal use of print to output text from your programs that would be useful for troubleshooting and monitoring progress.","title":"Print and string formatting"},{"location":"print/#simple-use-case","text":"You can pass any value to print that can be represented as a string Most types of data in Python can be represented as a string. print ( 'Hello, World!' ) print ( 1 ) print ( 3.14 ) print ( True ) print ( None ) print ([ 1 , 2 , 3 ])","title":"Simple use case"},{"location":"print/#string-formatting","text":"Format strings allow you to create more complex strings containing plain text and existing variables. Read the documentation String formatting is a whole mini-language within the Python language itself. I suggest referring to the official documentation for more.","title":"String formatting"},{"location":"print/#basic-example","text":"You define a format string like a any other string, except you must prefix the string with a f . Within the format string, you can use curly braces {} to reference a variable a = 'World' print ( f 'Hello, { a } !' ) In this example, Python will substitute the placeholder {a} with the value from the variable a which will result in the string Hello, World! .","title":"Basic example"},{"location":"print/#real-world-example","text":"Format strings are sometimes used to dynamically build shell commands. For example files = [ [ 'subject_a.dcm' , 'subject_a.nii.gz' ], [ 'subject_b.dcm' , 'subject_b.nii.gz' ], [ 'subject_c.dcm' , 'subject_c.nii.gz' ] ] for infile , outfile in files : command = f 'mri_convert { infile } { outfile } ' print ( command ) This will print the following shell commands mri_convert subject_a.dcm subject_a.nii.gz mri_convert subject_b.dcm subject_b.nii.gz mri_convert subject_c.dcm subject_c.nii.gz","title":"Real world example"},{"location":"print/#rounding-floats","text":"It's common for a developer to specify how a float value should be displayed within a formatted string. To do this, you can add a format specifier to your placeholder using {variable:specifier} syntax. For example, if you want your format string to round the variable pi to 4 decimal places, you would append 0.4f to pi pi = 3.1415926 print ( f '\u03c0 rounded to 4 decimal places is { pi : 0.4f } ' ) For more information on format specifiers, refer to the official documentation here .","title":"Rounding floats"},{"location":"recommendations/","text":"Recommendations Here's a brief list of recommended Python packages. pipenv There is no universally accepted toolchain for building Python applications in a simple (nevermind deterministic ) way. I've tried a few different offerings but ultimately landed on pipenv . requests If you need to make HTTP requests, you should check out requests . I would like to add that this is perhaps one of the best API designs in the Python ecosystem. vcrpy If you ever need to mock out HTTP responses for testing, I've tried a bunch and landed on vcrpy . flask Need a web application by the end of the day? Try flask . mkdocs Writing documentation? Already know (or want to learn) Markdown? Try mkdocs .","title":"Recommendations"},{"location":"recommendations/#recommendations","text":"Here's a brief list of recommended Python packages.","title":"Recommendations"},{"location":"recommendations/#pipenv","text":"There is no universally accepted toolchain for building Python applications in a simple (nevermind deterministic ) way. I've tried a few different offerings but ultimately landed on pipenv .","title":"pipenv"},{"location":"recommendations/#requests","text":"If you need to make HTTP requests, you should check out requests . I would like to add that this is perhaps one of the best API designs in the Python ecosystem.","title":"requests"},{"location":"recommendations/#vcrpy","text":"If you ever need to mock out HTTP responses for testing, I've tried a bunch and landed on vcrpy .","title":"vcrpy"},{"location":"recommendations/#flask","text":"Need a web application by the end of the day? Try flask .","title":"flask"},{"location":"recommendations/#mkdocs","text":"Writing documentation? Already know (or want to learn) Markdown? Try mkdocs .","title":"mkdocs"},{"location":"set/","text":"Data Structures Sets Sets allow you to accumulate items without duplicates. A set begins and ends with curly braces {} and each item is separated by a comma , Spaces don't matter here. a = { 1 , 1 , 2 , 1 , 2 , 2 } Note that even though we've added multiple instances of 1 and 2 , the set object only contains a single instance of 1 and 2 . >>> print ( a ) { 1 , 2 } Alternate syntax Unfortunately, Python also uses curly braces {} to define sets and dictionaries. The following will create an empty dictionary a = {} To create an empty set, you need to use the set() function without any arguments a = set () Set operations The set data type supports many conventional set operations. You can find the union , intersection , and difference between two sets using the following methods a = { 1 , 2 , 3 , 4 , 5 } b = { 1 , 5 , 6 , 7 , 8 } a . intersection ( b ) # intersection a . difference ( b ) # difference a . union ( b ) # union Adding and removing items You can add and remove items from a set using the add and remove methods a . add ( 10 ) a . remove ( 2 ) Indexing Sets, which are inherently unordered collections, do not support indexing.","title":"Set"},{"location":"set/#data-structures","text":"","title":"Data Structures"},{"location":"set/#sets","text":"Sets allow you to accumulate items without duplicates. A set begins and ends with curly braces {} and each item is separated by a comma , Spaces don't matter here. a = { 1 , 1 , 2 , 1 , 2 , 2 } Note that even though we've added multiple instances of 1 and 2 , the set object only contains a single instance of 1 and 2 . >>> print ( a ) { 1 , 2 }","title":"Sets"},{"location":"set/#alternate-syntax","text":"Unfortunately, Python also uses curly braces {} to define sets and dictionaries. The following will create an empty dictionary a = {} To create an empty set, you need to use the set() function without any arguments a = set ()","title":"Alternate syntax"},{"location":"set/#set-operations","text":"The set data type supports many conventional set operations. You can find the union , intersection , and difference between two sets using the following methods a = { 1 , 2 , 3 , 4 , 5 } b = { 1 , 5 , 6 , 7 , 8 } a . intersection ( b ) # intersection a . difference ( b ) # difference a . union ( b ) # union","title":"Set operations"},{"location":"set/#adding-and-removing-items","text":"You can add and remove items from a set using the add and remove methods a . add ( 10 ) a . remove ( 2 )","title":"Adding and removing items"},{"location":"set/#indexing","text":"Sets, which are inherently unordered collections, do not support indexing.","title":"Indexing"},{"location":"subprocess/","text":"Subprocesses Many neuroimaging analysis tools are implemented as a command line tool that does one thing and does it well . The subprocess module makes running command line tools simple. import subprocess Running a subprocess A simple way to run a subprocess is with subprocess.check_output . The first argument will be your command and the second argument will be shell=True output = subprocess . check_output ( 'ls -la' , shell = True ) print ( output . decode ()) string.decode() Python will no longer assume a character encoding for strings that are read in from files or generated by subprocesses. You're responsible for always calling .decode() with the known character encoding, which defaults to UTF-8. Handling errors If a subprocess fails, you'll receive a subprocess.CalledProcessError . An unhandled exception will typically crash your program. If you want to catch the error and handle it in a particular way, you can enclose the function call within a try statement try : output = subprocess . check_output ( 'ls -z' , shell = True ) except subprocess . CalledProcessError as e : print ( e . returncode )","title":"Subprocesses"},{"location":"subprocess/#subprocesses","text":"Many neuroimaging analysis tools are implemented as a command line tool that does one thing and does it well . The subprocess module makes running command line tools simple. import subprocess","title":"Subprocesses"},{"location":"subprocess/#running-a-subprocess","text":"A simple way to run a subprocess is with subprocess.check_output . The first argument will be your command and the second argument will be shell=True output = subprocess . check_output ( 'ls -la' , shell = True ) print ( output . decode ()) string.decode() Python will no longer assume a character encoding for strings that are read in from files or generated by subprocesses. You're responsible for always calling .decode() with the known character encoding, which defaults to UTF-8.","title":"Running a subprocess"},{"location":"subprocess/#handling-errors","text":"If a subprocess fails, you'll receive a subprocess.CalledProcessError . An unhandled exception will typically crash your program. If you want to catch the error and handle it in a particular way, you can enclose the function call within a try statement try : output = subprocess . check_output ( 'ls -z' , shell = True ) except subprocess . CalledProcessError as e : print ( e . returncode )","title":"Handling errors"},{"location":"tuple/","text":"Data Structures Tuples Tuples are effectively an immutable list. Once a tuple has been defined, you cannot add, update, or delete items from it. A tuple begins and ends with parentheses () and items are separated by a comma , Spaces don't matter here. a = ( 1 , 2 , 3 ) Indexing Like other iterable types in Python, you can index and slice tuples a [ 0 ] a [ 1 ] a [:: 2 ] Unpacking Often used in for loops, you can unpack a tuple into individual variables a , b , c = ( 1 , 2 , 3 ) In this case a = 1 , b = 2 , and c = 3 . Remember this pattern as it often appears in code and documentation. Immutability The immutability property of a tuple is desirable under some circumstances. For example, only immutable types in Python can be hashed and only hashable types can be used as dictionary keys. For example, this is perfectly legal code a = { ( 'StudyA' , 'Subject1' ): [ 'Session1' , 'Session2' ], ( 'StudyA' , 'Subject2' ): [ 'Session3' , 'Session4' ], ( 'StudyB' , 'Subject1' ): [ 'Session5' , 'Session6' ] } Note that you cannot hash a tuple if it contains a mutable type. and subsequently you can retrieve an item from this dictionary using ('StudyA','Subject2') a [( 'StudyA' , 'Subject2' )]","title":"Tuple"},{"location":"tuple/#data-structures","text":"","title":"Data Structures"},{"location":"tuple/#tuples","text":"Tuples are effectively an immutable list. Once a tuple has been defined, you cannot add, update, or delete items from it. A tuple begins and ends with parentheses () and items are separated by a comma , Spaces don't matter here. a = ( 1 , 2 , 3 )","title":"Tuples"},{"location":"tuple/#indexing","text":"Like other iterable types in Python, you can index and slice tuples a [ 0 ] a [ 1 ] a [:: 2 ]","title":"Indexing"},{"location":"tuple/#unpacking","text":"Often used in for loops, you can unpack a tuple into individual variables a , b , c = ( 1 , 2 , 3 ) In this case a = 1 , b = 2 , and c = 3 . Remember this pattern as it often appears in code and documentation.","title":"Unpacking"},{"location":"tuple/#immutability","text":"The immutability property of a tuple is desirable under some circumstances. For example, only immutable types in Python can be hashed and only hashable types can be used as dictionary keys. For example, this is perfectly legal code a = { ( 'StudyA' , 'Subject1' ): [ 'Session1' , 'Session2' ], ( 'StudyA' , 'Subject2' ): [ 'Session3' , 'Session4' ], ( 'StudyB' , 'Subject1' ): [ 'Session5' , 'Session6' ] } Note that you cannot hash a tuple if it contains a mutable type. and subsequently you can retrieve an item from this dictionary using ('StudyA','Subject2') a [( 'StudyA' , 'Subject2' )]","title":"Immutability"},{"location":"virtualenv/","text":"Virtual environments Virtual environments will allow you to install and try out as many different Python packages as possible. Creating a virtual environment To create a virtual environment, execute the following shell command % python -m venv test This will create a directory named test . Activating your virtual environment To activate your virtual environment, execute the following shell command % source test/bin/activate You're now using an isolated/sandboxed Python installation under the test directory. You should notice that which python now points to the Python executable that resided within your virtual environment. deactivate To deactivate the virtual environment, execute the deactivate shell command ( test ) % deactivate You should notice that which python now points to the system installed Python executable. pip The main package installer for Python is pip . upgrade pip For the rest of this tutorial, you should only run pip from within an activated virtual environment . Before you proceed any further, you should upgrade pip ( test ) % pip install --upgrade pip Now you can install external packages such as pydicom ( test ) % pip install pydicom dependency management You may notice that when you install an external package such as pydicom , this triggers the installation of additional packages. This creates a dependency graph . If we were to explore the dependency graph for the yaxil library, you would see the following The following graph was rendered with pipenv yaxil==0.4.3 - arrow [required: Any, installed: 0.15.5] - python-dateutil [required: Any, installed: 2.8.1] - six [required: >=1.5, installed: 1.14.0] - lxml [required: Any, installed: 4.5.0] - pyaml [required: Any, installed: 19.12.0] - PyYAML [required: Any, installed: 5.3] - pydicom [required: Any, installed: 1.4.1] - requests [required: Any, installed: 2.22.0] - certifi [required: >=2017.4.17, installed: 2019.11.28] - chardet [required: >=3.0.2,<3.1.0, installed: 3.0.4] - idna [required: >=2.5,<2.9, installed: 2.8] - urllib3 [required: >=1.21.1,<1.26,!=1.25.1,!=1.25.0, installed: 1.25.8] - six [required: Any, installed: 1.14.0] You can see that yaxil depends on arrow , lxml , pydicom , requests , and six and in turn, each of those dependencies have their own dependencies. Diving deeper, you'll see that arrow depends on python-dateutil which in turn depends on six >= 1.5 . Coincidentally, yaxil also depends on six and will accept Any version. But what if it didn't? If these two packages had conflicting requirements, there would be a dependency conflict .","title":"Virtual environments"},{"location":"virtualenv/#virtual-environments","text":"Virtual environments will allow you to install and try out as many different Python packages as possible.","title":"Virtual environments"},{"location":"virtualenv/#creating-a-virtual-environment","text":"To create a virtual environment, execute the following shell command % python -m venv test This will create a directory named test .","title":"Creating a virtual environment"},{"location":"virtualenv/#activating-your-virtual-environment","text":"To activate your virtual environment, execute the following shell command % source test/bin/activate You're now using an isolated/sandboxed Python installation under the test directory. You should notice that which python now points to the Python executable that resided within your virtual environment.","title":"Activating your virtual environment"},{"location":"virtualenv/#deactivate","text":"To deactivate the virtual environment, execute the deactivate shell command ( test ) % deactivate You should notice that which python now points to the system installed Python executable.","title":"deactivate"},{"location":"virtualenv/#pip","text":"The main package installer for Python is pip .","title":"pip"},{"location":"virtualenv/#upgrade-pip","text":"For the rest of this tutorial, you should only run pip from within an activated virtual environment . Before you proceed any further, you should upgrade pip ( test ) % pip install --upgrade pip Now you can install external packages such as pydicom ( test ) % pip install pydicom","title":"upgrade pip"},{"location":"virtualenv/#dependency-management","text":"You may notice that when you install an external package such as pydicom , this triggers the installation of additional packages. This creates a dependency graph . If we were to explore the dependency graph for the yaxil library, you would see the following The following graph was rendered with pipenv yaxil==0.4.3 - arrow [required: Any, installed: 0.15.5] - python-dateutil [required: Any, installed: 2.8.1] - six [required: >=1.5, installed: 1.14.0] - lxml [required: Any, installed: 4.5.0] - pyaml [required: Any, installed: 19.12.0] - PyYAML [required: Any, installed: 5.3] - pydicom [required: Any, installed: 1.4.1] - requests [required: Any, installed: 2.22.0] - certifi [required: >=2017.4.17, installed: 2019.11.28] - chardet [required: >=3.0.2,<3.1.0, installed: 3.0.4] - idna [required: >=2.5,<2.9, installed: 2.8] - urllib3 [required: >=1.21.1,<1.26,!=1.25.1,!=1.25.0, installed: 1.25.8] - six [required: Any, installed: 1.14.0] You can see that yaxil depends on arrow , lxml , pydicom , requests , and six and in turn, each of those dependencies have their own dependencies. Diving deeper, you'll see that arrow depends on python-dateutil which in turn depends on six >= 1.5 . Coincidentally, yaxil also depends on six and will accept Any version. But what if it didn't? If these two packages had conflicting requirements, there would be a dependency conflict .","title":"dependency management"},{"location":"while/","text":"Control of flow The while loop A while loop will execute the same block of code until a specified condition returns True . For example a = 0 while a <= 10 : print ( 'a is' , a ) a += 1 The infinite loop A common convention for creating an infinite loop is to use a while loop given a condition that will never return False Stopping an infinite loop The example below will print Hello, World! continuously until you hit Control + C while True : print ( 'Hello, World!' )","title":"while"},{"location":"while/#control-of-flow","text":"","title":"Control of flow"},{"location":"while/#the-while-loop","text":"A while loop will execute the same block of code until a specified condition returns True . For example a = 0 while a <= 10 : print ( 'a is' , a ) a += 1","title":"The while loop"},{"location":"while/#the-infinite-loop","text":"A common convention for creating an infinite loop is to use a while loop given a condition that will never return False Stopping an infinite loop The example below will print Hello, World! continuously until you hit Control + C while True : print ( 'Hello, World!' )","title":"The infinite loop"}]}