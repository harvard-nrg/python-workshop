{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python for Neuroimaging! A brief history Python is a high-level, interpreted language created by Guido van Rossum . 2 to 3 Python has undergone three major revisions since it's initial release back in 1991. The most recent transition was from Python 2 to 3. Python 2 was officially deprecated on January 1st, 2020. The interpreter Instead of compiling source code into machine code Python executes your code one line at a time using an interpreter . starting the interpreter Python should be installed by default on most Linux and macOS systems. To start the interpreter, simply open a terminal and type python or python3 at the command prompt and hit Enter % python Python 3.8.2 (default, Mar 26 2020, 15:43:04) [Clang 11.0.3 (clang-1103.0.32.29)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Command not found If you receive a command not found error, either your system does not have Python installed, or your environment is misconfigured. Try logging into a FASSE host and use one of the existing Python modules module load ncf module load miniconda3/py39_4.11.0-ncf If that doesn't work, please contact a system administrator . executing statements You can execute statements interactively by typing a statement at the prompt >>> and pressing Enter >>> 1 + 1 2 >>> Python will read the input statement, evaluate it, print the result, and loop back to the command prompt. This is known as a read-evaluate-print-loop or REPL. comments Any lines beginning with a hash # are comments and will be ignored >>> # this is a comment For multi-line comments, you can use multiple # characters, or you can use triple quotes (single or double quotes work) \"\"\" I am a multiline comment \"\"\" quitting To quit the Python interpreter, type Control + D or execute the quit() or exit() functions >>> quit ()","title":"Introduction"},{"location":"#welcome-to-python-for-neuroimaging","text":"","title":"Welcome to Python for Neuroimaging!"},{"location":"#a-brief-history","text":"Python is a high-level, interpreted language created by Guido van Rossum .","title":"A brief history"},{"location":"#2-to-3","text":"Python has undergone three major revisions since it's initial release back in 1991. The most recent transition was from Python 2 to 3. Python 2 was officially deprecated on January 1st, 2020.","title":"2 to 3"},{"location":"#the-interpreter","text":"Instead of compiling source code into machine code Python executes your code one line at a time using an interpreter .","title":"The interpreter"},{"location":"#starting-the-interpreter","text":"Python should be installed by default on most Linux and macOS systems. To start the interpreter, simply open a terminal and type python or python3 at the command prompt and hit Enter % python Python 3.8.2 (default, Mar 26 2020, 15:43:04) [Clang 11.0.3 (clang-1103.0.32.29)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Command not found If you receive a command not found error, either your system does not have Python installed, or your environment is misconfigured. Try logging into a FASSE host and use one of the existing Python modules module load ncf module load miniconda3/py39_4.11.0-ncf If that doesn't work, please contact a system administrator .","title":"starting the interpreter"},{"location":"#executing-statements","text":"You can execute statements interactively by typing a statement at the prompt >>> and pressing Enter >>> 1 + 1 2 >>> Python will read the input statement, evaluate it, print the result, and loop back to the command prompt. This is known as a read-evaluate-print-loop or REPL.","title":"executing statements"},{"location":"#comments","text":"Any lines beginning with a hash # are comments and will be ignored >>> # this is a comment For multi-line comments, you can use multiple # characters, or you can use triple quotes (single or double quotes work) \"\"\" I am a multiline comment \"\"\"","title":"comments"},{"location":"#quitting","text":"To quit the Python interpreter, type Control + D or execute the quit() or exit() functions >>> quit ()","title":"quitting"},{"location":"basics/","text":"Variables, assignment, and types This may seem a bit elementary, but let's quickly review how to define variables and go over the primitive types available in Python. Defining a variable Enter the following statement at the Python command prompt >>> to define the variable pi pi = 3.1415 You do not need to use let , var , or provide any type hinting keywords before the variable declaration. You also don't need a semicolon at the end of each statement. defining a variable from an expression The right side of a variable assignment does not need to be a static value. It can also be an expression a = 1 + 1 Python will evaluate the right side of the assignment operator and send the result to the left. This left-right associative property allows you to use an existing variable to redefine itself a = a + 1 Primitive types Python includes several low-level \"primitive\" data types by default such as integers int , decimals float , strings str , booleans bool , and a special value for null None . Here are some examples a = 1 # int b = 3.14 # float c = \"I'm a double quoted string\" # str d = 'I \\' m a single quoted string' # str e = True # bool f = False # bool g = None # None Should I define strings use single or double quotes Using single or double quotes is mostly a stylistic choice. However, if you intend to use a single quote within a single-quoted string, or a double quote within a double-quoted string, you'll need to escape the embedded quote with a backslash \\ character as shown above. Checking types You can check the type of a variable (or its class ) at any time by passing it to the built-in type() function. type ( a )","title":"Variables and primitive types"},{"location":"basics/#variables-assignment-and-types","text":"This may seem a bit elementary, but let's quickly review how to define variables and go over the primitive types available in Python.","title":"Variables, assignment, and types"},{"location":"basics/#defining-a-variable","text":"Enter the following statement at the Python command prompt >>> to define the variable pi pi = 3.1415 You do not need to use let , var , or provide any type hinting keywords before the variable declaration. You also don't need a semicolon at the end of each statement.","title":"Defining a variable"},{"location":"basics/#defining-a-variable-from-an-expression","text":"The right side of a variable assignment does not need to be a static value. It can also be an expression a = 1 + 1 Python will evaluate the right side of the assignment operator and send the result to the left. This left-right associative property allows you to use an existing variable to redefine itself a = a + 1","title":"defining a variable from an expression"},{"location":"basics/#primitive-types","text":"Python includes several low-level \"primitive\" data types by default such as integers int , decimals float , strings str , booleans bool , and a special value for null None . Here are some examples a = 1 # int b = 3.14 # float c = \"I'm a double quoted string\" # str d = 'I \\' m a single quoted string' # str e = True # bool f = False # bool g = None # None Should I define strings use single or double quotes Using single or double quotes is mostly a stylistic choice. However, if you intend to use a single quote within a single-quoted string, or a double quote within a double-quoted string, you'll need to escape the embedded quote with a backslash \\ character as shown above.","title":"Primitive types"},{"location":"basics/#checking-types","text":"You can check the type of a variable (or its class ) at any time by passing it to the built-in type() function. type ( a )","title":"Checking types"},{"location":"cli/","text":"Writing command line tools We've covered a lot of ground. Now that we have a handle on the Python interpreter and some fundamental Python syntax, we can take the commands we've been plugging into the interpreter and create a command line application. Basic example To begin, open a new file named hello.py and enter the following contents #!/usr/bin/env python print ( 'Hello, World!' ) Save the file and make it executable using the following shell command % chmod u+x hello.py Now you can execute your script from the command line % ./hello.py Hello, World! Real world example Let's take a look at a real-world example. The command line application shown below will use the yaxil package to query a public data set on central.xnat.org , retrieve all of the scan numbers, and download those scans into a directory named ./xnat-data #!/usr/bin/env python import yaxil xnat = 'central-xnat' project = 'CENTRAL_OASIS_LONG' label = 'OAS2_0001_MR2' out_dir = './xnat-data' auth = yaxil . auth ( xnat ) scan_ids = [] for scan in yaxil . scans ( auth , label , project = project ): scan_id = scan [ 'id' ] scan_ids . append ( scan_id ) yaxil . download ( auth , label , scan_ids , out_dir = out_dir ) The only shortcoming is that the variables xnat , project , label , and out_dir are baked into the application. The next section will show you how to turn these into command line arguments . Command line arguments Suppose that you wrote a XNAT downloader script, named downloader.py , that you wanted to accept xnat , project , label , and out_dir on the command line % ./downloader.py --xnat central-xnat --project CENTRAL_OASIS_LONG --label OAS2_0001_MR2 --out-dir ./xnat-data You can certainly access the raw command line arguments by importing the sys module and sifting through sys.argv import sys print ( sys . argv ) But that's going to be a lot of work to parse. Fortunately, there's a much cleaner way to define and parse command line arguments using one of my favorite modules, argparse . Read the docs The argparse module is truly brilliant. The functionality demonstrated here does not do it justice. I highly recommend that you take the time to browse the official documentation here . defining First, import the argparse module and create an argparse.ArgumentParser object import argparse parser = argparse . ArgumentParser () Now, add your arguments to the parser object by calling parser.add_argument() parser = argparse . ArgumentParser () parser . add_argument ( '--xnat' ) parser . add_argument ( '--project' ) parser . add_argument ( '--label' ) parser . add_argument ( '--out-dir' ) parsing Now you can call parser.parse_args() to parse the user supplied command line arguments args = parser . parse_args () To access each argument, take the argument name, remove any leading dashes - , replace any embedded dashes - with an underscore _ , and you should be able to access that property on the args object print ( 'xnat is' , args . xnat ) print ( 'project is' , args . project ) print ( 'label is' , args . label ) print ( 'out_dir is' , args . out_dir ) Exercises Exercise 1 Try adding command line arguments to the real world example .","title":"Writing command line tools"},{"location":"cli/#writing-command-line-tools","text":"We've covered a lot of ground. Now that we have a handle on the Python interpreter and some fundamental Python syntax, we can take the commands we've been plugging into the interpreter and create a command line application.","title":"Writing command line tools"},{"location":"cli/#basic-example","text":"To begin, open a new file named hello.py and enter the following contents #!/usr/bin/env python print ( 'Hello, World!' ) Save the file and make it executable using the following shell command % chmod u+x hello.py Now you can execute your script from the command line % ./hello.py Hello, World!","title":"Basic example"},{"location":"cli/#real-world-example","text":"Let's take a look at a real-world example. The command line application shown below will use the yaxil package to query a public data set on central.xnat.org , retrieve all of the scan numbers, and download those scans into a directory named ./xnat-data #!/usr/bin/env python import yaxil xnat = 'central-xnat' project = 'CENTRAL_OASIS_LONG' label = 'OAS2_0001_MR2' out_dir = './xnat-data' auth = yaxil . auth ( xnat ) scan_ids = [] for scan in yaxil . scans ( auth , label , project = project ): scan_id = scan [ 'id' ] scan_ids . append ( scan_id ) yaxil . download ( auth , label , scan_ids , out_dir = out_dir ) The only shortcoming is that the variables xnat , project , label , and out_dir are baked into the application. The next section will show you how to turn these into command line arguments .","title":"Real world example"},{"location":"cli/#command-line-arguments","text":"Suppose that you wrote a XNAT downloader script, named downloader.py , that you wanted to accept xnat , project , label , and out_dir on the command line % ./downloader.py --xnat central-xnat --project CENTRAL_OASIS_LONG --label OAS2_0001_MR2 --out-dir ./xnat-data You can certainly access the raw command line arguments by importing the sys module and sifting through sys.argv import sys print ( sys . argv ) But that's going to be a lot of work to parse. Fortunately, there's a much cleaner way to define and parse command line arguments using one of my favorite modules, argparse . Read the docs The argparse module is truly brilliant. The functionality demonstrated here does not do it justice. I highly recommend that you take the time to browse the official documentation here .","title":"Command line arguments"},{"location":"cli/#defining","text":"First, import the argparse module and create an argparse.ArgumentParser object import argparse parser = argparse . ArgumentParser () Now, add your arguments to the parser object by calling parser.add_argument() parser = argparse . ArgumentParser () parser . add_argument ( '--xnat' ) parser . add_argument ( '--project' ) parser . add_argument ( '--label' ) parser . add_argument ( '--out-dir' )","title":"defining"},{"location":"cli/#parsing","text":"Now you can call parser.parse_args() to parse the user supplied command line arguments args = parser . parse_args () To access each argument, take the argument name, remove any leading dashes - , replace any embedded dashes - with an underscore _ , and you should be able to access that property on the args object print ( 'xnat is' , args . xnat ) print ( 'project is' , args . project ) print ( 'label is' , args . label ) print ( 'out_dir is' , args . out_dir )","title":"parsing"},{"location":"cli/#exercises","text":"Exercise 1 Try adding command line arguments to the real world example .","title":"Exercises"},{"location":"conditional/","text":"Control flow Comparison operators Python provides fairly conventional relational operators to compare two values and return a boolean result operator description < less than > greater than == is equal to != is not equal to <= less than or equal to >= greater than or equal to Some examples include 1 < 2 2 > 1 1 == 1 1 != 2 2 <= 3 3 >= 2 Boolean operators Also referred to as logical operators , boolean operators are often used to create conjunctions operator desription logic symbol and logical and p \u2227 q or logical or p \u2228 q not logical not \u00acp Some examples include 2 > 1 and 2 < 3 True or False True and not False Truthiness of values Python will interpret empty values as False and non-empty values as True . For example, it's common to execute a block of code if a list is empty. One way to do this would be a = [] if len ( a ) == 0 : print ( 'the list is empty' ) but since Python will interpret an empty list as False , you can do the following instead if not a : print ( 'the list is empty' ) Other values that evaluate to False include an empty string '' , an empty dictionary {} , the integer value 0 , the float value 0.0 , an empty tuple () , an empty set set() , and None . Exercises Exercise 1 Play around with conditional operators. Specifically, you should try comparing two strings with the less-than or greater-than operators.","title":"operators"},{"location":"conditional/#control-flow","text":"","title":"Control flow"},{"location":"conditional/#comparison-operators","text":"Python provides fairly conventional relational operators to compare two values and return a boolean result operator description < less than > greater than == is equal to != is not equal to <= less than or equal to >= greater than or equal to Some examples include 1 < 2 2 > 1 1 == 1 1 != 2 2 <= 3 3 >= 2","title":"Comparison operators"},{"location":"conditional/#boolean-operators","text":"Also referred to as logical operators , boolean operators are often used to create conjunctions operator desription logic symbol and logical and p \u2227 q or logical or p \u2228 q not logical not \u00acp Some examples include 2 > 1 and 2 < 3 True or False True and not False","title":"Boolean operators"},{"location":"conditional/#truthiness-of-values","text":"Python will interpret empty values as False and non-empty values as True . For example, it's common to execute a block of code if a list is empty. One way to do this would be a = [] if len ( a ) == 0 : print ( 'the list is empty' ) but since Python will interpret an empty list as False , you can do the following instead if not a : print ( 'the list is empty' ) Other values that evaluate to False include an empty string '' , an empty dictionary {} , the integer value 0 , the float value 0.0 , an empty tuple () , an empty set set() , and None .","title":"Truthiness of values"},{"location":"conditional/#exercises","text":"Exercise 1 Play around with conditional operators. Specifically, you should try comparing two strings with the less-than or greater-than operators.","title":"Exercises"},{"location":"dict/","text":"Data Structures Dictionaries Dictionaries are data structures that allow you to define custom indexes or keys . In other languages, dictionaries are referred to as hash maps , hash tables or associative arrays . Dictionaries begin and end with curly braces {} and each key/value pair (item) is separated by a comma , . You define your own keys and their corresponding values separated by a colon : a = { 'name' : 'Guido van Rossum' , 'yob' : 1956 } Indexing You can index into a dictionary using the keys that you defined a [ 'name' ] a [ 'yob' ] This is often easier and more robust than having to remember numeric indexes. Insert You can insert new items into an existing dictionary using the assignment = operator a [ 'job title' ] = 'BDFL' Update You can update an existing dictionary item using the assignment = operator a [ 'job title' ] = None Delete You can delete an item from a dictionary using the del keyword del a [ 'job title' ]","title":"Dict"},{"location":"dict/#data-structures","text":"","title":"Data Structures"},{"location":"dict/#dictionaries","text":"Dictionaries are data structures that allow you to define custom indexes or keys . In other languages, dictionaries are referred to as hash maps , hash tables or associative arrays . Dictionaries begin and end with curly braces {} and each key/value pair (item) is separated by a comma , . You define your own keys and their corresponding values separated by a colon : a = { 'name' : 'Guido van Rossum' , 'yob' : 1956 }","title":"Dictionaries"},{"location":"dict/#indexing","text":"You can index into a dictionary using the keys that you defined a [ 'name' ] a [ 'yob' ] This is often easier and more robust than having to remember numeric indexes.","title":"Indexing"},{"location":"dict/#insert","text":"You can insert new items into an existing dictionary using the assignment = operator a [ 'job title' ] = 'BDFL'","title":"Insert"},{"location":"dict/#update","text":"You can update an existing dictionary item using the assignment = operator a [ 'job title' ] = None","title":"Update"},{"location":"dict/#delete","text":"You can delete an item from a dictionary using the del keyword del a [ 'job title' ]","title":"Delete"},{"location":"files/","text":"Reading and writing files Reading a file To read from file, simply open the file using the built-in open() function and call .read() on the resulting file object fo = open ( 'file.txt' ) content = fo . read () To close the file, call close() on the file object fo . close () character encoding The result from calling fo.read() can sometimes yield a byte-string. Python will not automatically decode strings for you. To decode the result, you must know the character encoding and call the .decode() method. If the string is in utf-8 for example, you would call content = content . decode ( 'utf-8' ) UTF-8 is common but by no means the only character encoding. Writing a file The process for writing a file is similar to reading. Again, you need to open the file using the built-in open() function, but this time you must open the file in write mode using w as the second positional argument fo = open ( 'file.txt' , 'w' ) fo . write ( 'Hello, World! \\n ' ) It's more important to call .close() after writing to a file to ensure that the write buffer has been flushed to disk fo . close () Appending to a file Similar to writing, appending content to an existing file requires opening the file in append mode using a as the second positional argument fo = open ( 'file.txt' , 'a' ) fo . write ( another line ') fo . close () File context manager Forgetting to call close() is a common mistake. Fortunately, the file object returned by open() supports the context manager interface. To use a context manager, you must wrap the function call in a with statement with open ( 'file.txt' , 'w' ) as fo : fo . write ( 'Hello, World! \\n ' ) The primary benefit is that as soon as you dedent the with block, the file will be closed. CSV files Since reading CSV files is so common, we'll take some time to explore the csv module. To begin using the csv module, import it import csv Reading CSV (basic) Suppose this is the CSV file we're trying to read Subject,Metric 1,Metric 2 Subject_001,1,1 Subject_002,2,0 Subject_003,3,1 We would open this CSV file using open() function, then pass the resulting file object to csv.reader() . This will return a CSV reader object fo = open ( 'file.csv' ) reader = csv . reader ( fo ) Since an open CSV reader object is iterable, you can loop over it row-by-row using a for loop for row in reader : print ( row ) This loop will print the following text to the console. As shown here, each row is parsed and returned as a list [ 'Subject' , 'Metric 1' , 'Metric 2' ] [ 'Subject_001' , '1' , '1' ] [ 'Subject_002' , '2' , '0' ] [ 'Subject_003' , '3' , '1' ] Dictionary reader The first row of a CSV file usually contains column headers. It's fairly common to combine each row with the column headers so that you can retrive items using dict indexing. Here's the long form version of this The example below is for illustrative purposes. There's a better way. fo = open ( 'file.csv' ) reader = csv . reader ( fo ) headers = next ( reader ) # get the first row for row in reader : # iterate over the remaining rows row = dict ( zip ( headers , row )) # combine headers and values print ( row [ 'Metric 1' ]) You shouldn't bother with all of that. This is so common that the csv module includes a csv.DictReader to do it for you fo = open ( 'file.csv' ) reader = csv . DictReader ( fo ) for row in reader : print ( row [ 'Metric 1' ]) Pandas You should also check out pandas which has even more advanced CSV parsing and querying capabilities.","title":"Reading and writing files"},{"location":"files/#reading-and-writing-files","text":"","title":"Reading and writing files"},{"location":"files/#reading-a-file","text":"To read from file, simply open the file using the built-in open() function and call .read() on the resulting file object fo = open ( 'file.txt' ) content = fo . read () To close the file, call close() on the file object fo . close ()","title":"Reading a file"},{"location":"files/#character-encoding","text":"The result from calling fo.read() can sometimes yield a byte-string. Python will not automatically decode strings for you. To decode the result, you must know the character encoding and call the .decode() method. If the string is in utf-8 for example, you would call content = content . decode ( 'utf-8' ) UTF-8 is common but by no means the only character encoding.","title":"character encoding"},{"location":"files/#writing-a-file","text":"The process for writing a file is similar to reading. Again, you need to open the file using the built-in open() function, but this time you must open the file in write mode using w as the second positional argument fo = open ( 'file.txt' , 'w' ) fo . write ( 'Hello, World! \\n ' ) It's more important to call .close() after writing to a file to ensure that the write buffer has been flushed to disk fo . close ()","title":"Writing a file"},{"location":"files/#appending-to-a-file","text":"Similar to writing, appending content to an existing file requires opening the file in append mode using a as the second positional argument fo = open ( 'file.txt' , 'a' ) fo . write ( another line ') fo . close ()","title":"Appending to a file"},{"location":"files/#file-context-manager","text":"Forgetting to call close() is a common mistake. Fortunately, the file object returned by open() supports the context manager interface. To use a context manager, you must wrap the function call in a with statement with open ( 'file.txt' , 'w' ) as fo : fo . write ( 'Hello, World! \\n ' ) The primary benefit is that as soon as you dedent the with block, the file will be closed.","title":"File context manager"},{"location":"files/#csv-files","text":"Since reading CSV files is so common, we'll take some time to explore the csv module. To begin using the csv module, import it import csv","title":"CSV files"},{"location":"files/#reading-csv-basic","text":"Suppose this is the CSV file we're trying to read Subject,Metric 1,Metric 2 Subject_001,1,1 Subject_002,2,0 Subject_003,3,1 We would open this CSV file using open() function, then pass the resulting file object to csv.reader() . This will return a CSV reader object fo = open ( 'file.csv' ) reader = csv . reader ( fo ) Since an open CSV reader object is iterable, you can loop over it row-by-row using a for loop for row in reader : print ( row ) This loop will print the following text to the console. As shown here, each row is parsed and returned as a list [ 'Subject' , 'Metric 1' , 'Metric 2' ] [ 'Subject_001' , '1' , '1' ] [ 'Subject_002' , '2' , '0' ] [ 'Subject_003' , '3' , '1' ]","title":"Reading CSV (basic)"},{"location":"files/#dictionary-reader","text":"The first row of a CSV file usually contains column headers. It's fairly common to combine each row with the column headers so that you can retrive items using dict indexing. Here's the long form version of this The example below is for illustrative purposes. There's a better way. fo = open ( 'file.csv' ) reader = csv . reader ( fo ) headers = next ( reader ) # get the first row for row in reader : # iterate over the remaining rows row = dict ( zip ( headers , row )) # combine headers and values print ( row [ 'Metric 1' ]) You shouldn't bother with all of that. This is so common that the csv module includes a csv.DictReader to do it for you fo = open ( 'file.csv' ) reader = csv . DictReader ( fo ) for row in reader : print ( row [ 'Metric 1' ]) Pandas You should also check out pandas which has even more advanced CSV parsing and querying capabilities.","title":"Dictionary reader"},{"location":"for/","text":"Control flow The for loop A for loop allows the same block of code to be executed multiple times. The general format of a for loop is as follows for item in iterable : code to be executed Iteration Many of the data structures that we've encountered are iterable . Suppose we have a list of scan information. Each item in the list is a dict containing various scan properties scans = [ { 'num' : 1 , 'type' : 'LOCALIZER' , }, { 'num' : 2 , 'type' : 'MEMPRAGE' }, { 'num' : 3 , 'type' : 'BOLD' }, { 'num' : 4 , 'type' : 'BOLD' } ] If you want to retrieve the scan numbers for all BOLD scans, you could use a for loop to iterate over the scans list and call the same block of code to populate a numbers list numbers = [] for scan in scans : if scan [ 'type' ] == 'BOLD' : numbers . append ( scan [ 'num' ]) print ( numbers ) Iterating over a dict It's also possible to iterate over a dict , but there are some slight differences. By default, when you iterate over a dict you'll only receive its keys. For example a = { 'key1' : 1 , 'key2' : 2 , 'key3' : 3 } for key in a : value = a [ key ] print ( value ) If you want to iterate over the dict returning key and value pairs, you can use the following syntax for key , value in a . items (): print ( 'key =' , key , 'value =' , value ) Note that the above for loop is using tuple unpacking .","title":"for"},{"location":"for/#control-flow","text":"","title":"Control flow"},{"location":"for/#the-for-loop","text":"A for loop allows the same block of code to be executed multiple times. The general format of a for loop is as follows for item in iterable : code to be executed","title":"The for loop"},{"location":"for/#iteration","text":"Many of the data structures that we've encountered are iterable . Suppose we have a list of scan information. Each item in the list is a dict containing various scan properties scans = [ { 'num' : 1 , 'type' : 'LOCALIZER' , }, { 'num' : 2 , 'type' : 'MEMPRAGE' }, { 'num' : 3 , 'type' : 'BOLD' }, { 'num' : 4 , 'type' : 'BOLD' } ] If you want to retrieve the scan numbers for all BOLD scans, you could use a for loop to iterate over the scans list and call the same block of code to populate a numbers list numbers = [] for scan in scans : if scan [ 'type' ] == 'BOLD' : numbers . append ( scan [ 'num' ]) print ( numbers )","title":"Iteration"},{"location":"for/#iterating-over-a-dict","text":"It's also possible to iterate over a dict , but there are some slight differences. By default, when you iterate over a dict you'll only receive its keys. For example a = { 'key1' : 1 , 'key2' : 2 , 'key3' : 3 } for key in a : value = a [ key ] print ( value ) If you want to iterate over the dict returning key and value pairs, you can use the following syntax for key , value in a . items (): print ( 'key =' , key , 'value =' , value ) Note that the above for loop is using tuple unpacking .","title":"Iterating over a dict"},{"location":"formats/","text":"DICOM and NIFTI In this section, we're going to look at two really great Python libraries for interacting with neuroimaging file formats pydicom and nibabel . Use a virtual environment To have full control over installing the packages described within this section, consider using virtual environment demonstrated here . dicom DICOM is a very popular file format (and transmission protocol) used within the medical imaging community. Certainly one of the more popular packages for reading and writing DICOM files in Python is pydicom . installation To install pydicom use pip pip install pydicom You'll also want to install numpy to access more advanced functionality pip install numpy After you've installed pydicom , you can import it import pydicom read To read a DICOM file into variable named ds , use pydicom.dcmread() ds = pydicom . dcmread ( 'file.dcm' ) Lazy loading The pydicom.dcmread() function will only read the DICOM file headers until you attempt to access the pixel data. This design pattern can save time and resources. headers DICOM headers are traditionally identified by group and element pairs. Some common DICOM headers are Name group element Study Date 0008 0020 Study Time 0008 0030 Patient Name 0010 0010 Series Number 0020 0011 Accession Number 0008 0050 Instance ID 0020 0013 Study UID 0020 000D Series UID 0020 000E You can access these DICOM headers by indexing into the ds object using a tuple of ( group, element ) . To access the Patient Name for example, you would use element = ds [( '0010' , '0010' )] In the above example, the returned value ( element ) will be an instance of pydicom.dataelem.DataElement . To access the actual value of the header, you want to access the value property of the data element patientname = element . value pixel data To read the DICOM image pixel data as a series of bytes, you can access the PixelData property on the ds object pixels = ds . PixelData To receive the pixel data as a more useful NumPy array, you would use the pixel_array property pixels = ds . pixel_array nifti For reading NIFTI files, I would highly recommend using the nibabel package. installing To install nibabel , use pip pip install nibabel After you've installed nibabel , you can import it import nibabel read To read a NIFTI file, use nibabel.load() ds = nibabel . load ( 'file.nii.gz' ) headers The NIFTI file headers are stored in a header property on the ds object shown above. Since the header property is dict -like, you can use a for loop to iterate over all the header names and values formatter = 'header = {} , value = {} ' for header , value in ds . header . items (): a = formatter . format ( header , value ) print ( a ) pixel data The NIFTI pixel data can be accessed using the .get_fdata() method which will return the data as a NumPy array pixels = ds . get_fdata () Memory efficiency The ds.get_fdata() method has many features for handling large images efficiently. For more details, read the official documentation here .","title":"DICOM and NIFTI"},{"location":"formats/#dicom-and-nifti","text":"In this section, we're going to look at two really great Python libraries for interacting with neuroimaging file formats pydicom and nibabel . Use a virtual environment To have full control over installing the packages described within this section, consider using virtual environment demonstrated here .","title":"DICOM and NIFTI"},{"location":"formats/#dicom","text":"DICOM is a very popular file format (and transmission protocol) used within the medical imaging community. Certainly one of the more popular packages for reading and writing DICOM files in Python is pydicom .","title":"dicom"},{"location":"formats/#installation","text":"To install pydicom use pip pip install pydicom You'll also want to install numpy to access more advanced functionality pip install numpy After you've installed pydicom , you can import it import pydicom","title":"installation"},{"location":"formats/#read","text":"To read a DICOM file into variable named ds , use pydicom.dcmread() ds = pydicom . dcmread ( 'file.dcm' ) Lazy loading The pydicom.dcmread() function will only read the DICOM file headers until you attempt to access the pixel data. This design pattern can save time and resources.","title":"read"},{"location":"formats/#headers","text":"DICOM headers are traditionally identified by group and element pairs. Some common DICOM headers are Name group element Study Date 0008 0020 Study Time 0008 0030 Patient Name 0010 0010 Series Number 0020 0011 Accession Number 0008 0050 Instance ID 0020 0013 Study UID 0020 000D Series UID 0020 000E You can access these DICOM headers by indexing into the ds object using a tuple of ( group, element ) . To access the Patient Name for example, you would use element = ds [( '0010' , '0010' )] In the above example, the returned value ( element ) will be an instance of pydicom.dataelem.DataElement . To access the actual value of the header, you want to access the value property of the data element patientname = element . value","title":"headers"},{"location":"formats/#pixel-data","text":"To read the DICOM image pixel data as a series of bytes, you can access the PixelData property on the ds object pixels = ds . PixelData To receive the pixel data as a more useful NumPy array, you would use the pixel_array property pixels = ds . pixel_array","title":"pixel data"},{"location":"formats/#nifti","text":"For reading NIFTI files, I would highly recommend using the nibabel package.","title":"nifti"},{"location":"formats/#installing","text":"To install nibabel , use pip pip install nibabel After you've installed nibabel , you can import it import nibabel","title":"installing"},{"location":"formats/#read_1","text":"To read a NIFTI file, use nibabel.load() ds = nibabel . load ( 'file.nii.gz' )","title":"read"},{"location":"formats/#headers_1","text":"The NIFTI file headers are stored in a header property on the ds object shown above. Since the header property is dict -like, you can use a for loop to iterate over all the header names and values formatter = 'header = {} , value = {} ' for header , value in ds . header . items (): a = formatter . format ( header , value ) print ( a )","title":"headers"},{"location":"formats/#pixel-data_1","text":"The NIFTI pixel data can be accessed using the .get_fdata() method which will return the data as a NumPy array pixels = ds . get_fdata () Memory efficiency The ds.get_fdata() method has many features for handling large images efficiently. For more details, read the official documentation here .","title":"pixel data"},{"location":"functions/","text":"Functions Calling functions We've seen a several examples of calling functions already. The simplest form takes one or more positional arguments . The sorted() function for example can be called with only a single positional argument The sorted() function will sort any iterable object, such as a list . a = [ 3 , 1 , 5 , 4 , 2 ] sorted ( a ) However, if you look at the function signature for sorted() , you'll see that it can accept 2 additional arguments def sorted ( iterable , key = None , reverse = False ) These arguments have default values None and False , but you can target either by keyword to override that default. For example, you can pass reverse=True to reverse the sort sorted ( a , reverse = True ) Defining functions Functions are defined using the def keyword, followed by the name of the function, followed by a comma separated list of arguments within parentheses def function ( a , b , c ) This is known as the function signature . The function implementation should exist below the signature in an indented block Be sure to insert a colon : after the function signature. def function ( a , b , c ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Now that the function has a signature and an implementation, you can invoke it like any other function from the standard libary function ( 1 , 2 , 3 ) This will print the following text to the console a is 1 b is 2 c is 3 keyword arguments Positional arguments are always declared first in a function signature. These arguments will be required to invoke the function. If you have any optional arguments, those must be declared after the positional arguments using the keyword=default syntax def function ( a , b = 8 , c = 16 ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Given the function definition above, a would be required, b would be optional (with a default value of 8 ), and c would be optional (with a default value of 16 ). If you wish to specify either of these optional arguments, you can target them by keyword . For example function ( 1 , c = 3 ) This would print the following text to the console a is 1 b is 8 c is 3 Returning values Often, you will want your function to manipulate data and return a result. This is achieved using a return statement def function ( a , b , c ): return ( a + b ) / c If your function has a return value, you can store that value within a variable using the assignment operator = result = function ( 1 , 2 , 3 )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#calling-functions","text":"We've seen a several examples of calling functions already. The simplest form takes one or more positional arguments . The sorted() function for example can be called with only a single positional argument The sorted() function will sort any iterable object, such as a list . a = [ 3 , 1 , 5 , 4 , 2 ] sorted ( a ) However, if you look at the function signature for sorted() , you'll see that it can accept 2 additional arguments def sorted ( iterable , key = None , reverse = False ) These arguments have default values None and False , but you can target either by keyword to override that default. For example, you can pass reverse=True to reverse the sort sorted ( a , reverse = True )","title":"Calling functions"},{"location":"functions/#defining-functions","text":"Functions are defined using the def keyword, followed by the name of the function, followed by a comma separated list of arguments within parentheses def function ( a , b , c ) This is known as the function signature . The function implementation should exist below the signature in an indented block Be sure to insert a colon : after the function signature. def function ( a , b , c ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Now that the function has a signature and an implementation, you can invoke it like any other function from the standard libary function ( 1 , 2 , 3 ) This will print the following text to the console a is 1 b is 2 c is 3","title":"Defining functions"},{"location":"functions/#keyword-arguments","text":"Positional arguments are always declared first in a function signature. These arguments will be required to invoke the function. If you have any optional arguments, those must be declared after the positional arguments using the keyword=default syntax def function ( a , b = 8 , c = 16 ): print ( 'a is' , a ) print ( 'b is' , b ) print ( 'c is' , c ) Given the function definition above, a would be required, b would be optional (with a default value of 8 ), and c would be optional (with a default value of 16 ). If you wish to specify either of these optional arguments, you can target them by keyword . For example function ( 1 , c = 3 ) This would print the following text to the console a is 1 b is 8 c is 3","title":"keyword arguments"},{"location":"functions/#returning-values","text":"Often, you will want your function to manipulate data and return a result. This is achieved using a return statement def function ( a , b , c ): return ( a + b ) / c If your function has a return value, you can store that value within a variable using the assignment operator = result = function ( 1 , 2 , 3 )","title":"Returning values"},{"location":"if/","text":"Control flow The if condition The general syntax of an if statement in Python is if condition : code to execute if True Indentation is important Python uses indentation to denote a block of code. Part of the reason is to enforce a consistent coding style . A block of code is considered open on indent and closed on dedent. Let's look at the trivial example below. Because a == 10 returns True , the indented block of code will be executed a = 10 if a == 10 : print ( 'condition is True' ) The else clause If you want to run a different block of code if the evaluated condition returns False , you can add an else clause if a == 0 : print ( 'condition is True' ) else : print ( 'condition is False' ) The elif clause We can further complicate this if statement by adding an elif clause, which is short for \"else if\" if a == 0 : print ( 'a is equal to 0' ) elif a == 10 : print ( 'a is equal to 10' ) else : print ( 'a is not equal to 0 or 10' )","title":"if"},{"location":"if/#control-flow","text":"","title":"Control flow"},{"location":"if/#the-if-condition","text":"The general syntax of an if statement in Python is if condition : code to execute if True Indentation is important Python uses indentation to denote a block of code. Part of the reason is to enforce a consistent coding style . A block of code is considered open on indent and closed on dedent. Let's look at the trivial example below. Because a == 10 returns True , the indented block of code will be executed a = 10 if a == 10 : print ( 'condition is True' )","title":"The if condition"},{"location":"if/#the-else-clause","text":"If you want to run a different block of code if the evaluated condition returns False , you can add an else clause if a == 0 : print ( 'condition is True' ) else : print ( 'condition is False' )","title":"The else clause"},{"location":"if/#the-elif-clause","text":"We can further complicate this if statement by adding an elif clause, which is short for \"else if\" if a == 0 : print ( 'a is equal to 0' ) elif a == 10 : print ( 'a is equal to 10' ) else : print ( 'a is not equal to 0 or 10' )","title":"The elif clause"},{"location":"learn/","text":"Machine learning Certaintly one of the better known software packages for machine learning in Python is scikit-learn . In this section, we'll dip our toes in with a simple classification example. Use a virtual environment To have full control over installing the packages described within this section, consider using virtual environment demonstrated here . Installation To install scikit-learn, use pip pip install scikit-learn The name of the module you'll import will be sklearn import sklearn Iris data set One of the canonical examples within the machine learning community is classifying Iris plants from various petal and sepal features. This is such a common example in fact, the Iris data set is included within sklearn . All you have to do is import the datasets module and load it from sklearn import datasets iris = datasets . load_iris () The Iris data set contains 150 examples of Iris plant. There are 50 examples of 3 classes, or targets \u2014 setosa, versicolour, and virgincia. Each example contains 4 different measurements, or features \u2014 sepal length, sepal width, petal length, and petal width. The sklearn data set contains the features in iris.data and the corresponding classes are found within iris.target . Building a classifier In this example, we'll build a Decision Tree classifier to predict Iris plants from petal and sepal features. First, we'll load the tree module from sklearn import tree Next, we'll create a DecisionTreeClassifer with a maximum depth of 2 classifier = tree . DecisionTreeClassifier ( max_depth = 2 ) Fitting data (training) We can train our classifier on the data set using the fit method classifier = classifier . fit ( iris . data , iris . target ) Visualizing the classifer Before moving on to prediction, let's visualize our classifier using the export_text function from sklearn.tree from sklearn.tree import export_text text = export_text ( classifier , feature_names = iris [ 'feature_names' ]) print ( text ) You should see the following output |--- petal length ( cm ) <= 2.45 | |--- class : 0 |--- petal length ( cm ) > 2.45 | |--- petal width ( cm ) <= 1.75 | | |--- class : 1 | |--- petal width ( cm ) > 1.75 | | |--- class : 2 Class names for this example can be found in iris['target_names'] . Prediction Given an unseen input feature vector [ 1.0, 1.0, 2.5, 1.75 ] you can predict its class using the .predict() method on our new model classifier . predict ([[ 1.0 , 1.0 , 2.5 , 1.75 ]]) This should return class 1 . If you manually run this input vector through the Decision Tree rules yourself, you can verify that this is correct.","title":"Machine learning primer"},{"location":"learn/#machine-learning","text":"Certaintly one of the better known software packages for machine learning in Python is scikit-learn . In this section, we'll dip our toes in with a simple classification example. Use a virtual environment To have full control over installing the packages described within this section, consider using virtual environment demonstrated here .","title":"Machine learning"},{"location":"learn/#installation","text":"To install scikit-learn, use pip pip install scikit-learn The name of the module you'll import will be sklearn import sklearn","title":"Installation"},{"location":"learn/#iris-data-set","text":"One of the canonical examples within the machine learning community is classifying Iris plants from various petal and sepal features. This is such a common example in fact, the Iris data set is included within sklearn . All you have to do is import the datasets module and load it from sklearn import datasets iris = datasets . load_iris () The Iris data set contains 150 examples of Iris plant. There are 50 examples of 3 classes, or targets \u2014 setosa, versicolour, and virgincia. Each example contains 4 different measurements, or features \u2014 sepal length, sepal width, petal length, and petal width. The sklearn data set contains the features in iris.data and the corresponding classes are found within iris.target .","title":"Iris data set"},{"location":"learn/#building-a-classifier","text":"In this example, we'll build a Decision Tree classifier to predict Iris plants from petal and sepal features. First, we'll load the tree module from sklearn import tree Next, we'll create a DecisionTreeClassifer with a maximum depth of 2 classifier = tree . DecisionTreeClassifier ( max_depth = 2 )","title":"Building a classifier"},{"location":"learn/#fitting-data-training","text":"We can train our classifier on the data set using the fit method classifier = classifier . fit ( iris . data , iris . target )","title":"Fitting data (training)"},{"location":"learn/#visualizing-the-classifer","text":"Before moving on to prediction, let's visualize our classifier using the export_text function from sklearn.tree from sklearn.tree import export_text text = export_text ( classifier , feature_names = iris [ 'feature_names' ]) print ( text ) You should see the following output |--- petal length ( cm ) <= 2.45 | |--- class : 0 |--- petal length ( cm ) > 2.45 | |--- petal width ( cm ) <= 1.75 | | |--- class : 1 | |--- petal width ( cm ) > 1.75 | | |--- class : 2 Class names for this example can be found in iris['target_names'] .","title":"Visualizing the classifer"},{"location":"learn/#prediction","text":"Given an unseen input feature vector [ 1.0, 1.0, 2.5, 1.75 ] you can predict its class using the .predict() method on our new model classifier . predict ([[ 1.0 , 1.0 , 2.5 , 1.75 ]]) This should return class 1 . If you manually run this input vector through the Decision Tree rules yourself, you can verify that this is correct.","title":"Prediction"},{"location":"list/","text":"Data structures Lists Also known as arrays in other languages, a list in Python begins and ends with square brackets [] and individual items are separated with a comma , . Spaces don't matter a = [ 1 , 2 , 3 , 4 ] Do I need to specify the size of the list in advance No. Since Python is interpreted and garbage collected there is no need to explicitly allocate memory, free memory, or declare the size of a list in advance. You can store any type of data in a list a = [ 'Hello' , 'World!' ] List items do not have to be the same type. You can create a list with items of several different types, including other lists a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] Split up long lines In the example below, you'll see a list printed with each item on a separate line. It's considered good practice to split lines at 80 characters for readability. Indexing Retrieving items from a list is called indexing or subscripting . Let's examine the list shown earlier a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] The list indexes are as follows index value type 0 1.0 float 1 'Hello, World!' str 2 [ 5.0, True, None ] list In Python, list indexes start at 0 and increment to the length of the list minus 1. Let's retrieve a few items from the list shown above a [ 0 ] a [ 1 ] a [ 2 ] Insert Python has a few different ways to insert new items into an existing list, but it's common to use the insert method. This method accepts two arguments. The first argument is a list index and the second argument is the value you wish to insert at that index a . insert ( 0 , 'foobar' ) This will insert the string foobar at index 0 , pushing all subsequent items forward. Update Use the assignment operator = to update an item at a specific index a [ 1 ] = 999 This will replace the value at index 1 with the integer value 999 . Delete You have to use the del keyword to delete an item from a list del a [ 1 ] This will delete the value at index 1 and shift all subsequent items back. Read the documentation Refer to the official documentation here for all available list operations. Length To see the length of a list, pass the list to the built-in len() function len ( a ) This function will return an int . Exists To check whether or not a specific value exists within a given list, use the in keyword 20 in a This statement will return a bool . Slicing Slicing is a powerful feature built into Python. If you've ever used Matlab, the syntax should be familiar. First, let's define a list containing the numbers 0 through 20 using the range function a = list ( range ( 1 , 21 )) Slice syntax is defined using start:end[:step] where step is optional. If you want to retrieve the first 10 items, you would specify the following slice a [ 0 : 10 ] If you omit the start index, it will default to zero a [: 10 ] If you want to get every other item, add a colon : and specify a step value a [: 20 : 2 ] If you don't know the length of the list, omit the end index which will default to the length of the list a [:: 2 ] For more advanced information, visit the official documentation here Exercises Exercise 1 Both str and list are considered iterables in Python. Because of this, some operations you can perform on a list you can also perform on a str , such as indexing and slicing.","title":"List"},{"location":"list/#data-structures","text":"","title":"Data structures"},{"location":"list/#lists","text":"Also known as arrays in other languages, a list in Python begins and ends with square brackets [] and individual items are separated with a comma , . Spaces don't matter a = [ 1 , 2 , 3 , 4 ] Do I need to specify the size of the list in advance No. Since Python is interpreted and garbage collected there is no need to explicitly allocate memory, free memory, or declare the size of a list in advance. You can store any type of data in a list a = [ 'Hello' , 'World!' ] List items do not have to be the same type. You can create a list with items of several different types, including other lists a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] Split up long lines In the example below, you'll see a list printed with each item on a separate line. It's considered good practice to split lines at 80 characters for readability.","title":"Lists"},{"location":"list/#indexing","text":"Retrieving items from a list is called indexing or subscripting . Let's examine the list shown earlier a = [ 1.0 , 'Hello, World!' , [ 5.0 , True , None ] ] The list indexes are as follows index value type 0 1.0 float 1 'Hello, World!' str 2 [ 5.0, True, None ] list In Python, list indexes start at 0 and increment to the length of the list minus 1. Let's retrieve a few items from the list shown above a [ 0 ] a [ 1 ] a [ 2 ]","title":"Indexing"},{"location":"list/#insert","text":"Python has a few different ways to insert new items into an existing list, but it's common to use the insert method. This method accepts two arguments. The first argument is a list index and the second argument is the value you wish to insert at that index a . insert ( 0 , 'foobar' ) This will insert the string foobar at index 0 , pushing all subsequent items forward.","title":"Insert"},{"location":"list/#update","text":"Use the assignment operator = to update an item at a specific index a [ 1 ] = 999 This will replace the value at index 1 with the integer value 999 .","title":"Update"},{"location":"list/#delete","text":"You have to use the del keyword to delete an item from a list del a [ 1 ] This will delete the value at index 1 and shift all subsequent items back. Read the documentation Refer to the official documentation here for all available list operations.","title":"Delete"},{"location":"list/#length","text":"To see the length of a list, pass the list to the built-in len() function len ( a ) This function will return an int .","title":"Length"},{"location":"list/#exists","text":"To check whether or not a specific value exists within a given list, use the in keyword 20 in a This statement will return a bool .","title":"Exists"},{"location":"list/#slicing","text":"Slicing is a powerful feature built into Python. If you've ever used Matlab, the syntax should be familiar. First, let's define a list containing the numbers 0 through 20 using the range function a = list ( range ( 1 , 21 )) Slice syntax is defined using start:end[:step] where step is optional. If you want to retrieve the first 10 items, you would specify the following slice a [ 0 : 10 ] If you omit the start index, it will default to zero a [: 10 ] If you want to get every other item, add a colon : and specify a step value a [: 20 : 2 ] If you don't know the length of the list, omit the end index which will default to the length of the list a [:: 2 ] For more advanced information, visit the official documentation here","title":"Slicing"},{"location":"list/#exercises","text":"Exercise 1 Both str and list are considered iterables in Python. Because of this, some operations you can perform on a list you can also perform on a str , such as indexing and slicing.","title":"Exercises"},{"location":"math/","text":"Math operators Python has fairly conventional mathematical operators for addition + , subtraction - , multiplication * , division / , and exponents ** . To demonstrate these, let's define two variables a and b a = 1 b = 10 and execute some basic arithmetic operations a + b a - b a * b a / b b ** 2 Dividing two int types returns a float If you're familiar with languages like C or Python 2, you might be surprised to find that Python 3 returns a float even when you're dividing two ints . Exercises Exercise 1 Feel free to play around with types and arithmetic expressions on your own. Define some variables, run some arithmetic expressions, and try to explore what happens if you multiply e.g., a str with an int .","title":"Math operators"},{"location":"math/#math-operators","text":"Python has fairly conventional mathematical operators for addition + , subtraction - , multiplication * , division / , and exponents ** . To demonstrate these, let's define two variables a and b a = 1 b = 10 and execute some basic arithmetic operations a + b a - b a * b a / b b ** 2 Dividing two int types returns a float If you're familiar with languages like C or Python 2, you might be surprised to find that Python 3 returns a float even when you're dividing two ints .","title":"Math operators"},{"location":"math/#exercises","text":"Exercise 1 Feel free to play around with types and arithmetic expressions on your own. Define some variables, run some arithmetic expressions, and try to explore what happens if you multiply e.g., a str with an int .","title":"Exercises"},{"location":"modules/","text":"Importing and using modules Up to this point, we've introduced various functions such as len() , set() , and type() . These are just a small number of the built-in functions available to your application the moment you start Python. In the following section we'll explore how to tap into the rest of the standard library by way of import statements. The os module The os module provides functions that allow you to interact with the operating system. To use functions from the os module, import it import os Joining paths You can easily combine strings with the appropriate path separator using os.path.join() os . path . join ( '/path/to/data/' , 'sub-001' , 'ses-001' ) This function will return the path /path/to/data/sub-001/ses-001 . Note that any redundant path separator characters / will be collapsed into a single character. Listing a directory The ls command line utility from GNU coreutils , will print directory entries to the console. This can also be achieved within Python using the os.listdir() function, which returns a list of files for entry in os . listdir ( '.' ): print ( entry ) Walking a directory If you want to walk over a directory and each subdirectory from the command line, you would likely reach for a command like ls -R or find . In Python, you can do this with os.walk for root , dirs , files in os . walk ( '.' ): for file in files : fullfile = os . path . join ( root , file ) print ( fullfile ) The os.walk() function returns a generator object. Generators are iterable and can be used with a for loop. On each iteration, you will recive a tuple containing the root directory, a list of directories, and a list of files. In the above example, we're using tuple unpacking into the separate variables root , dirs , and files . Table of shell commands Here's a quick list of commonly used Python functions and their corresponding Linux/UNIX commands Linux command Python function cd os.chdir pwd os.getcwd chmod os.chmod chown os.chown rm os.remove mv os.rename The shutil module While this is a little confusing, certain Linux commands have functional eqivalents in the os module while others are in the shutil module. To use functions from shutil , import the module import shutil Copying a file To copy a file, you should use shutil.copy2() . This function accepts arguments for the source and destination files shutil . copy2 ( '/path/source.txt' , '/path/destination.txt' ) There's more than one way to copy a file Python has multiple ways to copy a file. There's copy() , copyfile() , copyfileobj() , and copy2() . I tend to use copy2() since this function preserves file metadata. Frankly, I'm not sure under what circumstances you would want any other behavior. Copying a directory To copy an entire directory, you would typically use the cp -R commnad. In Python, you would use shutil.copytree() . This function accepts two arguments for the source and destination directories shutil . copytree ( '/path/source' , '/path/destination' ) Deleting a directory To delete an entire directory from the command line, you would typically reach for the rm -rf command and say a quick prayer. In Python, you would use shutil.rmtree() . This function accepts the directory to delete as its first argument Destructive command ahead You will not be asked for confirmation. Use at your own risk. shutil . rmtree ( '/be/careful' ) from x import y Instead of importing a module and calling a function like we've seen earlier import os os . listdir () you can use a from statement to import only the function you intend to use from os import listdir listdir ()","title":"Importing modules"},{"location":"modules/#importing-and-using-modules","text":"Up to this point, we've introduced various functions such as len() , set() , and type() . These are just a small number of the built-in functions available to your application the moment you start Python. In the following section we'll explore how to tap into the rest of the standard library by way of import statements.","title":"Importing and using modules"},{"location":"modules/#the-os-module","text":"The os module provides functions that allow you to interact with the operating system. To use functions from the os module, import it import os","title":"The os module"},{"location":"modules/#joining-paths","text":"You can easily combine strings with the appropriate path separator using os.path.join() os . path . join ( '/path/to/data/' , 'sub-001' , 'ses-001' ) This function will return the path /path/to/data/sub-001/ses-001 . Note that any redundant path separator characters / will be collapsed into a single character.","title":"Joining paths"},{"location":"modules/#listing-a-directory","text":"The ls command line utility from GNU coreutils , will print directory entries to the console. This can also be achieved within Python using the os.listdir() function, which returns a list of files for entry in os . listdir ( '.' ): print ( entry )","title":"Listing a directory"},{"location":"modules/#walking-a-directory","text":"If you want to walk over a directory and each subdirectory from the command line, you would likely reach for a command like ls -R or find . In Python, you can do this with os.walk for root , dirs , files in os . walk ( '.' ): for file in files : fullfile = os . path . join ( root , file ) print ( fullfile ) The os.walk() function returns a generator object. Generators are iterable and can be used with a for loop. On each iteration, you will recive a tuple containing the root directory, a list of directories, and a list of files. In the above example, we're using tuple unpacking into the separate variables root , dirs , and files .","title":"Walking a directory"},{"location":"modules/#table-of-shell-commands","text":"Here's a quick list of commonly used Python functions and their corresponding Linux/UNIX commands Linux command Python function cd os.chdir pwd os.getcwd chmod os.chmod chown os.chown rm os.remove mv os.rename","title":"Table of shell commands"},{"location":"modules/#the-shutil-module","text":"While this is a little confusing, certain Linux commands have functional eqivalents in the os module while others are in the shutil module. To use functions from shutil , import the module import shutil","title":"The shutil module"},{"location":"modules/#copying-a-file","text":"To copy a file, you should use shutil.copy2() . This function accepts arguments for the source and destination files shutil . copy2 ( '/path/source.txt' , '/path/destination.txt' ) There's more than one way to copy a file Python has multiple ways to copy a file. There's copy() , copyfile() , copyfileobj() , and copy2() . I tend to use copy2() since this function preserves file metadata. Frankly, I'm not sure under what circumstances you would want any other behavior.","title":"Copying a file"},{"location":"modules/#copying-a-directory","text":"To copy an entire directory, you would typically use the cp -R commnad. In Python, you would use shutil.copytree() . This function accepts two arguments for the source and destination directories shutil . copytree ( '/path/source' , '/path/destination' )","title":"Copying a directory"},{"location":"modules/#deleting-a-directory","text":"To delete an entire directory from the command line, you would typically reach for the rm -rf command and say a quick prayer. In Python, you would use shutil.rmtree() . This function accepts the directory to delete as its first argument Destructive command ahead You will not be asked for confirmation. Use at your own risk. shutil . rmtree ( '/be/careful' )","title":"Deleting a directory"},{"location":"modules/#from-x-import-y","text":"Instead of importing a module and calling a function like we've seen earlier import os os . listdir () you can use a from statement to import only the function you intend to use from os import listdir listdir ()","title":"from x import y"},{"location":"print/","text":"Print and string formatting One of the most tried and true debugging tools you will ever encounter is print . Logging is your friend Make liberal use of print to output text from your programs that would be useful for troubleshooting and monitoring progress. Simple use case You can pass any value to print that can be represented as a str , which happens to be most values in Python print ( 'Hello, World!' ) print ( 1 ) print ( 3.14 ) print ( True ) print ( None ) print ([ 1 , 2 , 3 ]) String formatting Format strings allow you to create more complex strings that contain plain text and values from existing variables. Read the documentation String formatting is nothing short of a mini-language within the Python language itself. I'll suggest that you refer to the official documentation here . Basic example You define a format string like a regular string, except you must prefix the string with a single f character. Within the format string, you can use curly brace {} notation to refer to an existing variable a = 'World' print ( f 'Hello, { a } !' ) In the example above, Python will substitute the placeholder {a} with the value from the variable a resulting in the printed string Hello, World! . Real world example Format strings can be used to dynamically build shell commands that you want to execute. For example files = [ [ 'subject_a.dcm' , 'subject_a.nii.gz' ], [ 'subject_b.dcm' , 'subject_b.nii.gz' ], [ 'subject_c.dcm' , 'subject_c.nii.gz' ] ] for infile , outfile in files : command = f 'mri_convert { infile } { outfile } ' print ( command ) This will print the following 3 shell commands mri_convert subject_a.dcm subject_a.nii.gz mri_convert subject_b.dcm subject_b.nii.gz mri_convert subject_c.dcm subject_c.nii.gz Rounding floats It's common for developers to specify how a float value should be handled by a formatted string. To do this, you can add a format specifier to your placeholder using the {variable:specifier} syntax. For example, if you want your format string to round a variable pi to 4 decimal places, you would append 0.4f to pi . Both components should be separated by a colon : pi = 3.1415926 print ( f '\u03c0 rounded to 4 decimal places is { pi : 0.4f } ' ) For more information about format specifiers, please refer to the official documentation here .","title":"Print and string formatting"},{"location":"print/#print-and-string-formatting","text":"One of the most tried and true debugging tools you will ever encounter is print . Logging is your friend Make liberal use of print to output text from your programs that would be useful for troubleshooting and monitoring progress.","title":"Print and string formatting"},{"location":"print/#simple-use-case","text":"You can pass any value to print that can be represented as a str , which happens to be most values in Python print ( 'Hello, World!' ) print ( 1 ) print ( 3.14 ) print ( True ) print ( None ) print ([ 1 , 2 , 3 ])","title":"Simple use case"},{"location":"print/#string-formatting","text":"Format strings allow you to create more complex strings that contain plain text and values from existing variables. Read the documentation String formatting is nothing short of a mini-language within the Python language itself. I'll suggest that you refer to the official documentation here .","title":"String formatting"},{"location":"print/#basic-example","text":"You define a format string like a regular string, except you must prefix the string with a single f character. Within the format string, you can use curly brace {} notation to refer to an existing variable a = 'World' print ( f 'Hello, { a } !' ) In the example above, Python will substitute the placeholder {a} with the value from the variable a resulting in the printed string Hello, World! .","title":"Basic example"},{"location":"print/#real-world-example","text":"Format strings can be used to dynamically build shell commands that you want to execute. For example files = [ [ 'subject_a.dcm' , 'subject_a.nii.gz' ], [ 'subject_b.dcm' , 'subject_b.nii.gz' ], [ 'subject_c.dcm' , 'subject_c.nii.gz' ] ] for infile , outfile in files : command = f 'mri_convert { infile } { outfile } ' print ( command ) This will print the following 3 shell commands mri_convert subject_a.dcm subject_a.nii.gz mri_convert subject_b.dcm subject_b.nii.gz mri_convert subject_c.dcm subject_c.nii.gz","title":"Real world example"},{"location":"print/#rounding-floats","text":"It's common for developers to specify how a float value should be handled by a formatted string. To do this, you can add a format specifier to your placeholder using the {variable:specifier} syntax. For example, if you want your format string to round a variable pi to 4 decimal places, you would append 0.4f to pi . Both components should be separated by a colon : pi = 3.1415926 print ( f '\u03c0 rounded to 4 decimal places is { pi : 0.4f } ' ) For more information about format specifiers, please refer to the official documentation here .","title":"Rounding floats"},{"location":"recommendations/","text":"Recommendations Here's a brief list of recommended Python packages. pipenv There is no universally accepted toolchain for building Python applications in a simple (nevermind deterministic ) way. I've tried a few different offerings but ultimately landed on pipenv . requests If you need to make HTTP requests, you should check out requests . I would like to add that this is perhaps one of the best API designs in the Python ecosystem. vcrpy If you ever need to mock out HTTP responses for testing, I've tried a bunch and landed on vcrpy . flask Need a web application by the end of the day? Try flask . mkdocs Writing documentation? Already know (or want to learn) Markdown? Try mkdocs .","title":"Recommendations"},{"location":"recommendations/#recommendations","text":"Here's a brief list of recommended Python packages.","title":"Recommendations"},{"location":"recommendations/#pipenv","text":"There is no universally accepted toolchain for building Python applications in a simple (nevermind deterministic ) way. I've tried a few different offerings but ultimately landed on pipenv .","title":"pipenv"},{"location":"recommendations/#requests","text":"If you need to make HTTP requests, you should check out requests . I would like to add that this is perhaps one of the best API designs in the Python ecosystem.","title":"requests"},{"location":"recommendations/#vcrpy","text":"If you ever need to mock out HTTP responses for testing, I've tried a bunch and landed on vcrpy .","title":"vcrpy"},{"location":"recommendations/#flask","text":"Need a web application by the end of the day? Try flask .","title":"flask"},{"location":"recommendations/#mkdocs","text":"Writing documentation? Already know (or want to learn) Markdown? Try mkdocs .","title":"mkdocs"},{"location":"set/","text":"Data Structures Sets Sets allow you to accumulate items without duplicates. A set begins and ends with curly braces {} and each item is separated by a comma. Spaces don't matter a = { 1 , 1 , 2 , 1 , 2 , 2 } Even though we've added multiple instances of 1 and 2 , if you inspect the contents of this set you'll see that it contains only a single instance of 1 and 2 . >>> print ( a ) { 1 , 2 } Alternate syntax Python unfortnately uses curly braces {} to define both sets and dictionaries. As a result, the following will create an empty dictionary, not a set a = {} To create an empty set, you must use the set() function without any arguments a = set () Set operations The set data type supports conventional set operations. For example, you can find the union , intersection , and difference between two sets using the following methods a = { 1 , 2 , 3 , 4 , 5 } b = { 1 , 5 , 6 , 7 , 8 } a . intersection ( b ) # intersection a . difference ( b ) # difference a . union ( b ) # union Adding and removing items You can add and remove items from a set using the add and remove methods a . add ( 10 ) a . remove ( 2 ) Indexing Sets, which are inherently unordered collections of items, do not support indexing.","title":"Set"},{"location":"set/#data-structures","text":"","title":"Data Structures"},{"location":"set/#sets","text":"Sets allow you to accumulate items without duplicates. A set begins and ends with curly braces {} and each item is separated by a comma. Spaces don't matter a = { 1 , 1 , 2 , 1 , 2 , 2 } Even though we've added multiple instances of 1 and 2 , if you inspect the contents of this set you'll see that it contains only a single instance of 1 and 2 . >>> print ( a ) { 1 , 2 }","title":"Sets"},{"location":"set/#alternate-syntax","text":"Python unfortnately uses curly braces {} to define both sets and dictionaries. As a result, the following will create an empty dictionary, not a set a = {} To create an empty set, you must use the set() function without any arguments a = set ()","title":"Alternate syntax"},{"location":"set/#set-operations","text":"The set data type supports conventional set operations. For example, you can find the union , intersection , and difference between two sets using the following methods a = { 1 , 2 , 3 , 4 , 5 } b = { 1 , 5 , 6 , 7 , 8 } a . intersection ( b ) # intersection a . difference ( b ) # difference a . union ( b ) # union","title":"Set operations"},{"location":"set/#adding-and-removing-items","text":"You can add and remove items from a set using the add and remove methods a . add ( 10 ) a . remove ( 2 )","title":"Adding and removing items"},{"location":"set/#indexing","text":"Sets, which are inherently unordered collections of items, do not support indexing.","title":"Indexing"},{"location":"subprocess/","text":"Subprocesses Many neuroimaging tools are implemented as single command line tools that do a thing . To build more complex analysis streams, you will inevitably have to chain together several command line tools to build what's known as a pipeline . Python has very mature support for running subprocesses, some of which will be demonstrated here. The subprocess module Running commands from the command line is commonly referred to as running a subprocess . Running subprocesses in Python is achieved using the subprocess module import subprocess Running a subprocess A very simple way to run a subprocess is by way of the subprocess.check_output() function. The first argument should be your command (as a str ) and the second argument should be shell=True which tells subprocess to run your command within a subshell. In the example below, we'll run the command ls -la , capture the console output into a variable named output , and print that output to the screen output = subprocess . check_output ( 'ls -la' , shell = True ) print ( output . decode ()) What's string.decode() Console output can be in any character encoding . Since Python can't doesn't automatically detect what encoding your string is in, you must call the decode() method, which defaults to utf-8 . Handling errors If a subprocess fails, you'll receive a subprocess.CalledProcessError . An uncaught exception like this will usually crash your program. But if you want to catch the error and handle it (perhaps by ignoring it), you can encapsulate your the function call in a try statement try : output = subprocess . check_output ( 'ls -z' , shell = True ) except subprocess . CalledProcessError as e : print ( e . returncode )","title":"Subprocesses"},{"location":"subprocess/#subprocesses","text":"Many neuroimaging tools are implemented as single command line tools that do a thing . To build more complex analysis streams, you will inevitably have to chain together several command line tools to build what's known as a pipeline . Python has very mature support for running subprocesses, some of which will be demonstrated here.","title":"Subprocesses"},{"location":"subprocess/#the-subprocess-module","text":"Running commands from the command line is commonly referred to as running a subprocess . Running subprocesses in Python is achieved using the subprocess module import subprocess","title":"The subprocess module"},{"location":"subprocess/#running-a-subprocess","text":"A very simple way to run a subprocess is by way of the subprocess.check_output() function. The first argument should be your command (as a str ) and the second argument should be shell=True which tells subprocess to run your command within a subshell. In the example below, we'll run the command ls -la , capture the console output into a variable named output , and print that output to the screen output = subprocess . check_output ( 'ls -la' , shell = True ) print ( output . decode ()) What's string.decode() Console output can be in any character encoding . Since Python can't doesn't automatically detect what encoding your string is in, you must call the decode() method, which defaults to utf-8 .","title":"Running a subprocess"},{"location":"subprocess/#handling-errors","text":"If a subprocess fails, you'll receive a subprocess.CalledProcessError . An uncaught exception like this will usually crash your program. But if you want to catch the error and handle it (perhaps by ignoring it), you can encapsulate your the function call in a try statement try : output = subprocess . check_output ( 'ls -z' , shell = True ) except subprocess . CalledProcessError as e : print ( e . returncode )","title":"Handling errors"},{"location":"tuple/","text":"Data Structures Tuples Tuples are essentially immutable lists. You cannot add, update, or delete items from an existing tuple. A tuple begins and ends with parentheses () and items are separated by a comma , . Spaces don't matter a = ( 1 , 2 , 3 ) Indexing Like other iterable types in Python, you can index and slice tuples a [ 0 ] a [ 1 ] a [:: 2 ] Unpacking Often used in for loops, you can unpack a tuple into individual variables a , b , c = ( 1 , 2 , 3 ) In this case a = 1 , b = 2 , and c = 3 . Immutability The immutability property of a tuple can be desirable in some circumstances. For example, only immutable types in Python can be hashed and only hashable types can be used as dictionary keys. Therefore, you can do this a = { ( 'StudyA' , 'Subject1' ): [ 'Session1' , 'Session2' ], ( 'StudyA' , 'Subject2' ): [ 'Session3' , 'Session4' ], ( 'StudyB' , 'Subject1' ): [ 'Session5' , 'Session6' ] } and subsequently retrieve an item from this dictionary using ( 'StudyA', 'Subject2' ) a [( 'StudyA' , 'Subject2' )]","title":"Tuple"},{"location":"tuple/#data-structures","text":"","title":"Data Structures"},{"location":"tuple/#tuples","text":"Tuples are essentially immutable lists. You cannot add, update, or delete items from an existing tuple. A tuple begins and ends with parentheses () and items are separated by a comma , . Spaces don't matter a = ( 1 , 2 , 3 )","title":"Tuples"},{"location":"tuple/#indexing","text":"Like other iterable types in Python, you can index and slice tuples a [ 0 ] a [ 1 ] a [:: 2 ]","title":"Indexing"},{"location":"tuple/#unpacking","text":"Often used in for loops, you can unpack a tuple into individual variables a , b , c = ( 1 , 2 , 3 ) In this case a = 1 , b = 2 , and c = 3 .","title":"Unpacking"},{"location":"tuple/#immutability","text":"The immutability property of a tuple can be desirable in some circumstances. For example, only immutable types in Python can be hashed and only hashable types can be used as dictionary keys. Therefore, you can do this a = { ( 'StudyA' , 'Subject1' ): [ 'Session1' , 'Session2' ], ( 'StudyA' , 'Subject2' ): [ 'Session3' , 'Session4' ], ( 'StudyB' , 'Subject1' ): [ 'Session5' , 'Session6' ] } and subsequently retrieve an item from this dictionary using ( 'StudyA', 'Subject2' ) a [( 'StudyA' , 'Subject2' )]","title":"Immutability"},{"location":"virtualenv/","text":"Installing packages Read this section to the end before doing anything I encourage you to read this entire section before attempting to install anything. Python has a thriving ecosystem and you should absolutely install and try as m any different libraries as possible. The following section will walk you through most of the installation options at your disposal. A brief history The original package manager for Python was easy_install , but you shouldn't use it to install anything except for pip sudo easy_install pip pip install The most basic command pip offers to install packages is This command is for illustrative purposes. Don't run it. pip install pydicom Unfortunatley, pip will by default attempt to install the package into a system location which requires administrative privileges. More often than not, you're not going to be able to use this option. pip install --user You can however instruct pip to install packages into your home directory using pip install -- user pydicom This will install the package under ~/.local on Linux or ~/Library/Python on macOS. To install into a custom location, there is also the --target option. Dependency conflicts You may run into issues when working on two or more projects that depend on different versions of the same package. This is an important use case for virtual environments. Keep reading. Virtual environments Ideally, for each software project you would have a separate Python installation and within that installation you could control exactly which external packages are installed. This is the purpose behind virtual environments . virtualenv Prior to Python 3.3, virtual environments were made possible by way of an external package virtualenv . Fortunately, this functionality is now built into Python 3 without the need for additional installs. create To create a virtual environment, execute the following shell command % python -m venv test This will create a directory named test . Congratulations \ud83c\udf89 you now have a virtual environment. Where is Python installed Before moving forward, take note of the location of the python executable on your system. This location will change after you've activated your virtual environment which python activate To activate your virtual environment, source the activation script % source test/bin/activate You shoule notice the string (test) has been prepended to your shell prompt. You're now using an isolated Python installation living under the test directory. You may also notice that which python now points to the python executable under your virtual environment. deactivate To deactivate the virtual environment, execute the deactivate command. Deactivation will return you to the original Python installation ( test ) % deactivate installing packages Once your virtual environment has been activated, you can proceed to install any external packages. These will be conveniently installed under your virtual environment directory ( test ) % pip install pydicom Dependency management The deeper you dive into dependency management, the more you're going to find. Reading up on deterministic builds is a fun place to start. dependency graph Just as you have your dependencies, you must also consider that your dependencies have their own dependencies too. You might even have overlapping dependencies. This is where things can get messy. If we explore the dependency graph for the yaxil project \u2014 which is a rather small project \u2014 you'll see the following dependency graph yaxil==0.4.3 - arrow [required: Any, installed: 0.15.5] - python-dateutil [required: Any, installed: 2.8.1] - six [required: >=1.5, installed: 1.14.0] - lxml [required: Any, installed: 4.5.0] - pyaml [required: Any, installed: 19.12.0] - PyYAML [required: Any, installed: 5.3] - pydicom [required: Any, installed: 1.4.1] - requests [required: Any, installed: 2.22.0] - certifi [required: >=2017.4.17, installed: 2019.11.28] - chardet [required: >=3.0.2,<3.1.0, installed: 3.0.4] - idna [required: >=2.5,<2.9, installed: 2.8] - urllib3 [required: >=1.21.1,<1.26,!=1.25.1,!=1.25.0, installed: 1.25.8] - six [required: Any, installed: 1.14.0] You can see here that yaxil depends directly on arrow , lxml , pydicom , requests , and six . That's just at the root level. Each of those dependencies have their own dependencies too, sometimes with even greater specificity. Looking more closely, you'll see that arrow depends on python-dateutil which in turn depends on six >= 1.5 . Coincidentally, yaxil also depends on six . Fortunately, it will accept any version. But what if it didn't? If these two packages had conflicting requirements, there would be a dependency conflict and you may not be alerted to this. pipenv Pipenv is a wonderful new tool that not only allows you to document your dependencies, it can also resolve your dependency graph and let you know if and where you've introduced a dependency conflict.","title":"Virtual environments"},{"location":"virtualenv/#installing-packages","text":"Read this section to the end before doing anything I encourage you to read this entire section before attempting to install anything. Python has a thriving ecosystem and you should absolutely install and try as m any different libraries as possible. The following section will walk you through most of the installation options at your disposal.","title":"Installing packages"},{"location":"virtualenv/#a-brief-history","text":"The original package manager for Python was easy_install , but you shouldn't use it to install anything except for pip sudo easy_install pip","title":"A brief history"},{"location":"virtualenv/#pip-install","text":"The most basic command pip offers to install packages is This command is for illustrative purposes. Don't run it. pip install pydicom Unfortunatley, pip will by default attempt to install the package into a system location which requires administrative privileges. More often than not, you're not going to be able to use this option.","title":"pip install"},{"location":"virtualenv/#pip-install-user","text":"You can however instruct pip to install packages into your home directory using pip install -- user pydicom This will install the package under ~/.local on Linux or ~/Library/Python on macOS. To install into a custom location, there is also the --target option. Dependency conflicts You may run into issues when working on two or more projects that depend on different versions of the same package. This is an important use case for virtual environments. Keep reading.","title":"pip install --user"},{"location":"virtualenv/#virtual-environments","text":"Ideally, for each software project you would have a separate Python installation and within that installation you could control exactly which external packages are installed. This is the purpose behind virtual environments . virtualenv Prior to Python 3.3, virtual environments were made possible by way of an external package virtualenv . Fortunately, this functionality is now built into Python 3 without the need for additional installs.","title":"Virtual environments"},{"location":"virtualenv/#create","text":"To create a virtual environment, execute the following shell command % python -m venv test This will create a directory named test . Congratulations \ud83c\udf89 you now have a virtual environment. Where is Python installed Before moving forward, take note of the location of the python executable on your system. This location will change after you've activated your virtual environment which python","title":"create"},{"location":"virtualenv/#activate","text":"To activate your virtual environment, source the activation script % source test/bin/activate You shoule notice the string (test) has been prepended to your shell prompt. You're now using an isolated Python installation living under the test directory. You may also notice that which python now points to the python executable under your virtual environment.","title":"activate"},{"location":"virtualenv/#deactivate","text":"To deactivate the virtual environment, execute the deactivate command. Deactivation will return you to the original Python installation ( test ) % deactivate","title":"deactivate"},{"location":"virtualenv/#installing-packages_1","text":"Once your virtual environment has been activated, you can proceed to install any external packages. These will be conveniently installed under your virtual environment directory ( test ) % pip install pydicom","title":"installing packages"},{"location":"virtualenv/#dependency-management","text":"The deeper you dive into dependency management, the more you're going to find. Reading up on deterministic builds is a fun place to start.","title":"Dependency management"},{"location":"virtualenv/#dependency-graph","text":"Just as you have your dependencies, you must also consider that your dependencies have their own dependencies too. You might even have overlapping dependencies. This is where things can get messy. If we explore the dependency graph for the yaxil project \u2014 which is a rather small project \u2014 you'll see the following dependency graph yaxil==0.4.3 - arrow [required: Any, installed: 0.15.5] - python-dateutil [required: Any, installed: 2.8.1] - six [required: >=1.5, installed: 1.14.0] - lxml [required: Any, installed: 4.5.0] - pyaml [required: Any, installed: 19.12.0] - PyYAML [required: Any, installed: 5.3] - pydicom [required: Any, installed: 1.4.1] - requests [required: Any, installed: 2.22.0] - certifi [required: >=2017.4.17, installed: 2019.11.28] - chardet [required: >=3.0.2,<3.1.0, installed: 3.0.4] - idna [required: >=2.5,<2.9, installed: 2.8] - urllib3 [required: >=1.21.1,<1.26,!=1.25.1,!=1.25.0, installed: 1.25.8] - six [required: Any, installed: 1.14.0] You can see here that yaxil depends directly on arrow , lxml , pydicom , requests , and six . That's just at the root level. Each of those dependencies have their own dependencies too, sometimes with even greater specificity. Looking more closely, you'll see that arrow depends on python-dateutil which in turn depends on six >= 1.5 . Coincidentally, yaxil also depends on six . Fortunately, it will accept any version. But what if it didn't? If these two packages had conflicting requirements, there would be a dependency conflict and you may not be alerted to this.","title":"dependency graph"},{"location":"virtualenv/#pipenv","text":"Pipenv is a wonderful new tool that not only allows you to document your dependencies, it can also resolve your dependency graph and let you know if and where you've introduced a dependency conflict.","title":"pipenv"},{"location":"while/","text":"Control of flow The while loop The while loop will execute the same block of code until a specified condition returns True . For example a = 0 while a <= 10 : print ( 'a is' , a ) a += 1 The infinite loop A common convention for creating an infinite loop is to use a while loop given a condition that will never return False Stopping an infinite loop The example below will print Hello, World! continuously until you hit Control + C while True : print ( 'Hello, World!' )","title":"while"},{"location":"while/#control-of-flow","text":"","title":"Control of flow"},{"location":"while/#the-while-loop","text":"The while loop will execute the same block of code until a specified condition returns True . For example a = 0 while a <= 10 : print ( 'a is' , a ) a += 1","title":"The while loop"},{"location":"while/#the-infinite-loop","text":"A common convention for creating an infinite loop is to use a while loop given a condition that will never return False Stopping an infinite loop The example below will print Hello, World! continuously until you hit Control + C while True : print ( 'Hello, World!' )","title":"The infinite loop"}]}